<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTS-Style Crowd Simulation with Enhanced Wall Collision</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        
        h1 {
            text-align: center;
            color: #00ffff;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-weight: 300;
        }
        
        #simulationCanvas {
            border: 2px solid #00ffff;
            display: block;
            margin: 0 auto 20px auto;
            background: #0a0a0a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .control-section {
            background: rgba(0, 20, 40, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        
        .control-section h3 {
            margin-top: 0;
            color: #00ffff;
            font-weight: 400;
            letter-spacing: 1px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
            opacity: 1;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 18px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            background: rgba(0, 20, 40, 0.8);
            color: #00ffff;
            font-weight: 300;
            letter-spacing: 0.5px;
            width: 160px;
            text-align: center;
            display: inline-block;
            box-sizing: border-box;
            white-space: nowrap;
        }
        
        button:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            transform: translateY(-1px);
        }
        
        .primary-btn {
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border: 1px solid #00ffff;
        }
        
        .primary-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        .secondary-btn {
            background: rgba(100, 100, 100, 0.2);
            color: #aaa;
            border: 1px solid #666;
        }
        
        .secondary-btn:hover {
            background: rgba(100, 100, 100, 0.3);
            color: #ccc;
        }
        
        .danger-btn {
            background: rgba(255, 0, 100, 0.1);
            color: #ff0066;
            border: 1px solid #ff0066;
        }
        
        .danger-btn:hover {
            background: rgba(255, 0, 100, 0.2);
            box-shadow: 0 0 20px rgba(255, 0, 100, 0.4);
        }
        
        .success-btn {
            background: rgba(0, 255, 100, 0.1);
            color: #00ff66;
            border: 1px solid #00ff66;
        }
        
        .success-btn:hover {
            background: rgba(0, 255, 100, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 100, 0.4);
        }
        
        .warning-btn {
            background: rgba(255, 200, 0, 0.1);
            color: #ffcc00;
            border: 1px solid #ffcc00;
        }
        
        .warning-btn:hover {
            background: rgba(255, 200, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 200, 0, 0.4);
        }
        
        .agent-type-btn {
            padding: 12px 18px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 20, 40, 0.6);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            color: #aaa;
            font-weight: 300;
            width: 250px;
            text-align: center;
            display: inline-block;
            box-sizing: border-box;
            white-space: nowrap;
        }
        
        .agent-type-btn:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
        }
        
        .agent-type-btn.active {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        /* Specific colors for each agent type */
        .agent-type-btn[data-type="0"] {
            border-color: #00BCD4;
            background: rgba(0, 188, 212, 0.1);
            color: #00BCD4;
        }
        
        .agent-type-btn[data-type="0"]:hover,
        .agent-type-btn[data-type="0"].active {
            background: rgba(0, 188, 212, 0.2);
            box-shadow: 0 0 15px rgba(0, 188, 212, 0.3);
        }
        
        .agent-type-btn[data-type="1"] {
            border-color: #B968C7;
            background: rgba(185, 104, 199, 0.1);
            color: #B968C7;
        }
        
        .agent-type-btn[data-type="1"]:hover,
        .agent-type-btn[data-type="1"].active {
            background: rgba(185, 104, 199, 0.2);
            box-shadow: 0 0 15px rgba(185, 104, 199, 0.3);
        }
        
        .agent-type-btn[data-type="2"] {
            border-color: #FF9800;
            background: rgba(255, 152, 0, 0.1);
            color: #FF9800;
        }
        
        .agent-type-btn[data-type="2"]:hover,
        .agent-type-btn[data-type="2"].active {
            background: rgba(255, 152, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.3);
        }
        
        .agent-type-btn[data-type="3"] {
            border-color: #FF5722;
            background: rgba(255, 87, 34, 0.1);
            color: #FF5722;
        }
        
        .agent-type-btn[data-type="3"]:hover,
        .agent-type-btn[data-type="3"].active {
            background: rgba(255, 87, 34, 0.2);
            box-shadow: 0 0 15px rgba(255, 87, 34, 0.3);
        }
        
        .agent-type-btn[data-type="4"] {
            border-color: #9C27B0;
            background: rgba(156, 39, 176, 0.1);
            color: #9C27B0;
        }
        
        .agent-type-btn[data-type="4"]:hover,
        .agent-type-btn[data-type="4"].active {
            background: rgba(156, 39, 176, 0.2);
            box-shadow: 0 0 15px rgba(156, 39, 176, 0.3);
        }
        
        .parameter-control {
            margin-bottom: 15px;
        }
        
        .parameter-control label {
            display: block;
            margin-bottom: 8px;
            font-weight: 300;
            color: #00ffff;
            letter-spacing: 0.5px;
        }
        
        .parameter-control input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .parameter-value {
            font-size: 12px;
            color: #aaa;
            text-align: right;
        }
        
        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .checkbox-control input[type="checkbox"] {
            margin: 0;
            accent-color: #00ffff;
        }
        
        .checkbox-control label {
            color: #ccc;
            margin-bottom: 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 12px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 300;
            color: #00ffff;
            display: block;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
        
        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
            letter-spacing: 0.5px;
        }
        
        .stat-item.clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .stat-item.clickable:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        
        .escape-time-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            max-height: 500px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .escape-time-popup h3 {
            color: #00ffff;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 18px;
        }
        
        .escape-time-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .escape-time-item:last-child {
            border-bottom: none;
        }
        
        .agent-sprite {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .escape-time-value {
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        .agents-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 500px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .agents-popup h3 {
            color: #00ffff;
            margin: 0 0 15px 0;
            text-align: center;
            font-size: 18px;
        }
        
        .agents-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .agents-table th {
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            padding: 10px 8px;
            text-align: left;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            font-size: 12px;
        }
        
        .agents-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            font-size: 12px;
        }
        
        .agents-table tr:hover {
            background: rgba(0, 255, 255, 0.05);
        }
        
        .agent-sprite-small {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .agent-camera {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            display: inline-block;
            position: relative;
            background: #000;
        }
        
        .camera-grid {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 0;
        }
        
        .camera-cell {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .camera-agent {
            background: #ff0000;
            border-radius: 50%;
        }
        
        .mode-indicator {
            background: rgba(255, 200, 0, 0.1);
            border: 1px solid rgba(255, 200, 0, 0.3);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            color: #ffcc00;
            margin-bottom: 15px;
        }
        
        .info-text {
            color: #e0e0e0;
            margin-bottom: 15px;
            line-height: 1.5;
            font-weight: 300;
        }
        
        .debug-info {
            font-size: 11px;
            color: #6c757d;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 3px;
            font-family: monospace;
            margin-top: 10px;
        }
        
        .info-text {
            font-size: 13px;
            color: #495057;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Crowd Simulation</h1>
        <p class="subtitle">Enhanced Wall Collision System - Agents Cannot Phase Through Walls</p>
        
        <canvas id="simulationCanvas" width="960" height="540"></canvas>
        
        <div class="info-bar">
            <span id="agentInfo">Agents: 0 | Walls: 0 | No destination set</span>
            <span id="performanceInfo">FPS: 0 | Time: 0.0s | Pathfinding: 0.0ms</span>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Simulation Control</h3>
                <div id="simulationStatus" style="margin-bottom: 10px; padding: 8px; background: rgba(0, 255, 255, 0.1); border-radius: 4px; text-align: center; color: #00ffff; font-weight: 400;">Stopped</div>
                <div class="button-group">
                    <button id="startBtn" class="primary-btn">Start Simulation</button>
                    <button id="stopBtn" class="secondary-btn">Stop Simulation</button>
                    <button id="resetBtn" class="danger-btn">Reset All</button>
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0, 255, 255, 0.2);">
                    <h4 style="color: #00ffff; margin: 0 0 10px 0; font-size: 14px;">AI Scenario Generator</h4>
                    <div class="info-text" style="margin-bottom: 8px; font-size: 11px;">Generate custom scenarios using AI</div>
                    
                    <div style="margin-bottom: 8px;">
                        <select id="llmProvider" style="width: 100%; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; font-size: 12px;">
                            <option value="gemini">Gemini (Cloud)</option>
                            <option value="ollama">Ollama (Local)</option>
                        </select>
                    </div>
                    
                    <div id="geminiConfig" style="margin-bottom: 8px;">
                        <input type="password" id="geminiApiKey" placeholder="Enter Gemini API Key" value="AIzaSyBArEQ9yPjf1nAKjM3mjT3aSd_FSrpuov0" style="width: 100%; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; font-size: 12px;">
                    </div>
                    
                    <div id="ollamaConfig" style="margin-bottom: 8px; display: none;">
                        <input type="text" id="ollamaUrl" placeholder="Ollama URL (e.g., http://localhost:11434 or http://192.168.1.100:11434)" value="http://localhost:11434" style="width: 100%; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; font-size: 12px; margin-bottom: 4px;">
                        <input type="text" id="ollamaModel" placeholder="Model name (e.g., llama3.1:8b)" value="llama3.1:8b" style="width: 100%; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; font-size: 12px;">
                    </div>
                    
                    <div style="margin-bottom: 8px;">
                        <textarea id="scenarioPrompt" placeholder="Describe the scenario (e.g., 'Create a school evacuation with multiple classrooms')" style="width: 100%; height: 50px; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; resize: vertical; font-size: 12px;"></textarea>
                    </div>
                    <div class="button-group">
                        <button id="generateScenarioBtn" class="primary-btn" style="font-size: 12px;">Generate Scenario</button>
                    </div>
                    <div id="generationProgress" style="color: #00ffff; font-size: 11px; margin-top: 6px; min-height: 14px;"></div>
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0, 255, 255, 0.2);">
                    <h4 style="color: #00ffff; margin: 0 0 10px 0; font-size: 14px;">Image Line Detection</h4>
                    <div class="info-text" style="margin-bottom: 8px; font-size: 11px;">Upload an image to automatically detect lines and create walls</div>
                    
                    <div style="margin-bottom: 8px;">
                        <input type="file" id="imageUpload" accept="image/*" style="width: 100%; padding: 6px; border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #e0e0e0; border-radius: 4px; font-size: 12px;">
                    </div>
                    
                    <div style="margin-bottom: 8px;">
                        <label style="font-size: 11px; color: #aaa;">Edge Margin: <span id="edgeMarginValue">10</span>px</label>
                        <input type="range" id="edgeMargin" min="5" max="50" value="10" style="width: 100%; margin-top: 4px;">
                    </div>
                    
                    <div class="button-group">
                        <button id="detectLinesBtn" class="primary-btn" style="font-size: 12px;">Construct</button>
                    </div>
                    <div id="detectionProgress" style="color: #00ffff; font-size: 11px; margin-top: 6px; min-height: 14px;"></div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Interactive Tools</h3>
                <div class="info-text">
                    <strong>Type 0:</strong> Visual Explorer (Limited vision, explores around obstacles)<br>
                    <strong>Type 1:</strong> Random Explorer (Infinite vision cone, explores randomly)<br>
                    <strong>Type 2:</strong> Informed Navigator (Full map knowledge, optimal A* pathfinding)<br>
                    <strong>Type 3:</strong> Follower (Follows nearest Type 2 agent with simple movement)<br>
                    <strong>Type 4:</strong> Smart Follower (Uses A* pathfinding to reach nearest Type 2 agent)
                </div>
                <div class="info-text">
                    <strong>Vision Systems:</strong> Type 1 agents can see the destination from anywhere within their directional cone. Other types have limited or map-based vision.
                </div>
                <div class="info-text">
                    <strong>Enhanced Wall Collision:</strong> Exponential repulsion forces prevent agents from phasing through walls even when heavily pushed by crowds.
                </div>
                
                <div class="button-group">
                    <div class="agent-type-btn" data-type="0"><strong>Type 0:</strong> Visual Explorer</div>
                    <div class="agent-type-btn active" data-type="1"><strong>Type 1:</strong> Random Explorer</div>
                    <div class="agent-type-btn" data-type="2"><strong>Type 2:</strong> Informed Navigator</div>
                    <div class="agent-type-btn" data-type="3"><strong>Type 3:</strong> Follower</div>
                    <div class="agent-type-btn" data-type="4"><strong>Type 4:</strong> Smart Follower</div>
                </div>
                
                <div class="button-group">
                    <button id="addAgentBtn" class="success-btn">Add Agents</button>
                    <button id="setDestinationBtn" class="warning-btn">Set Destination</button>
                    <button id="drawWallBtn" class="secondary-btn">Draw Walls</button>
                    <button id="drawBlockBtn" class="secondary-btn">Draw Blocks</button>
                    <button id="placeFireBtn" class="danger-btn">Place Fire</button>
                    <button id="eraserBtn" class="warning-btn">Eraser Tool</button>
                    <button id="doorBtn" class="primary-btn">Door Tool</button>
                    <button id="deleteBtn" class="danger-btn">Delete Tool</button>
                </div>
                
                <div id="modeIndicator" class="mode-indicator">Click on the canvas to add agents</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Agent Management</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span id="totalAgents" class="stat-value">0</span>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-item">
                        <span id="type0Agents" class="stat-value">0</span>
                        <div class="stat-label">Type 0</div>
                    </div>
                    <div class="stat-item">
                        <span id="type1Agents" class="stat-value">0</span>
                        <div class="stat-label">Type 1</div>
                    </div>
                    <div class="stat-item">
                        <span id="type2Agents" class="stat-value">0</span>
                        <div class="stat-label">Type 2</div>
                    </div>
                    <div class="stat-item">
                        <span id="type3Agents" class="stat-value">0</span>
                        <div class="stat-label">Type 3</div>
                    </div>
                    <div class="stat-item">
                        <span id="type4Agents" class="stat-value">0</span>
                        <div class="stat-label">Type 4</div>
                    </div>
                    <div class="stat-item">
                        <span id="avgSpeed" class="stat-value">0.00 m/s</span>
                        <div class="stat-label">Avg Speed</div>
                    </div>
                    <div class="stat-item">
                        <span id="deadCount" class="stat-value">0</span>
                        <div class="stat-label">Dead</div>
                    </div>
                    <div class="stat-item">
                        <span id="escapedCount" class="stat-value">0</span>
                        <div class="stat-label">Escaped</div>
                    </div>
                    <div class="stat-item" id="avgEscTimeBlock">
                        <span id="avgEscTime" class="stat-value">0.0s</span>
                        <div class="stat-label">Avg Esc. Time</div>
                    </div>
                    <div class="stat-item clickable" id="agentsBlock">
                        <span id="agentsCount" class="stat-value">0</span>
                        <div class="stat-label">Agents</div>
                    </div>
                </div>
                <div class="button-group">
                    <button id="addRandomBtn" class="success-btn" style="width: 200px;">Add 10 Random Agents</button>
                    <button id="clearAgentsBtn" class="danger-btn">Clear All Agents</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Environment</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span id="wallCount" class="stat-value">0</span>
                        <div class="stat-label">Obstacles</div>
                    </div>
                    <div class="stat-item">
                        <span id="fireCount" class="stat-value">0</span>
                        <div class="stat-label">Fires</div>
                    </div>
                    <div class="stat-item">
                        <span id="destinationStatus" class="stat-value">None</span>
                        <div class="stat-label">Destination</div>
                    </div>
                    <div class="stat-item" style="visibility: hidden;">
                        <span class="stat-value">-</span>
                        <div class="stat-label">-</div>
                    </div>
                    <div class="stat-item" style="visibility: hidden;">
                        <span class="stat-value">-</span>
                        <div class="stat-label">-</div>
                    </div>
                    <div class="stat-item" style="visibility: hidden;">
                        <span class="stat-value">-</span>
                        <div class="stat-label">-</div>
                    </div>
                    <div class="stat-item" style="visibility: hidden;">
                        <span class="stat-value">-</span>
                        <div class="stat-label">-</div>
                    </div>
                    <div class="stat-item" style="visibility: hidden;">
                        <span class="stat-value">-</span>
                        <div class="stat-label">-</div>
                    </div>
                </div>
                <div class="button-group">
                    <button id="clearWallsBtn" class="danger-btn">Clear All Walls</button>
                    <button id="clearFiresBtn" class="danger-btn">Clear All Fires</button>
                    <button id="clearDestinationBtn" class="danger-btn">Clear Destination</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visualization</h3>
                <div class="checkbox-control">
                    <input type="checkbox" id="showGrid">
                    <label for="showGrid">Show Pathfinding Grid</label>
                </div>
                <div class="checkbox-control">
                    <input type="checkbox" id="showPaths" checked>
                    <label for="showPaths">Show Agent Paths</label>
                </div>
                <div class="checkbox-control">
                    <input type="checkbox" id="showVisionCones">
                    <label for="showVisionCones">Show Vision Cones</label>
                </div>
                <div class="checkbox-control">
                    <input type="checkbox" id="showCollisionCircles">
                    <label for="showCollisionCircles">Show Collision Circles</label>
                </div>
                <div class="checkbox-control">
                    <input type="checkbox" id="showCongestion">
                    <label for="showCongestion">Show Congestion</label>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Scenarios</h3>
                <div class="button-group">
                    <button id="corridorBtn" class="primary-btn">Corridor with Exit</button>
                    <button id="roomBtn" class="primary-btn">Room Evacuation</button>
                    <button id="bottleneckBtn" class="primary-btn">Bottleneck Flow</button>
                    <button id="mazeBtn" class="primary-btn">Complex Maze</button>
                    <button id="classroomBtn" class="primary-btn">Classroom</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3>Parameters</h3>
                <div class="parameter-control">
                    <label for="maxSpeed">Max Speed <span id="maxSpeedValue" class="parameter-value">1.5 m/s</span></label>
                    <input type="range" id="maxSpeed" min="0.5" max="3.0" step="0.1" value="1.5">
                </div>
                <div class="parameter-control">
                    <label for="gridSize">Grid Cell Size <span id="gridSizeValue" class="parameter-value">10 px</span></label>
                    <input type="range" id="gridSize" min="5" max="20" step="1" value="10">
                </div>
                <div class="parameter-control">
                    <label for="pathfindingFreq">Pathfinding Frequency <span id="pathfindingFreqValue" class="parameter-value">1.0 s</span></label>
                    <input type="range" id="pathfindingFreq" min="0.1" max="3.0" step="0.1" value="1.0">
                </div>
                <div class="parameter-control">
                    <label for="collisionRadius">Collision Avoidance Radius <span id="collisionRadiusValue" class="parameter-value">30 px</span></label>
                    <input type="range" id="collisionRadius" min="10" max="60" step="5" value="30">
                </div>
                <div class="parameter-control">
                    <label for="collisionStrength">Collision Avoidance Strength <span id="collisionStrengthValue" class="parameter-value">0.8</span></label>
                    <input type="range" id="collisionStrength" min="0.1" max="2.0" step="0.1" value="0.8">
                </div>
                <div class="parameter-control">
                    <label for="wallRepulsionStrength">Wall Repulsion Strength <span id="wallRepulsionStrengthValue" class="parameter-value">5.0</span></label>
                    <input type="range" id="wallRepulsionStrength" min="1.0" max="10.0" step="0.5" value="5.0">
                </div>
                <div class="parameter-control">
                    <label for="visionConeDisplay">Vision Cone Display Size <span id="visionConeDisplayValue" class="parameter-value">80 px</span></label>
                    <input type="range" id="visionConeDisplay" min="30" max="150" step="10" value="80">
                </div>
                <div class="parameter-control">
                    <label for="visionAngle">Type 2 Vision Angle <span id="visionAngleValue" class="parameter-value">90°</span></label>
                    <input type="range" id="visionAngle" min="30" max="180" step="15" value="90">
                </div>
                <div class="parameter-control">
                    <label for="agentCollisionRadius">Agent Collision Circle <span id="agentCollisionRadiusValue" class="parameter-value">30 px</span></label>
                    <input type="range" id="agentCollisionRadius" min="10" max="60" step="5" value="30">
                </div>
                <div class="parameter-control">
                    <label for="wallRepulsionRange">Wall Repulsion Range <span id="wallRepulsionRangeValue" class="parameter-value">50 px</span></label>
                    <input type="range" id="wallRepulsionRange" min="20" max="100" step="10" value="50">
                </div>
            </div>
        </div>
        
        <div class="debug-info" id="debugInfo">
            Grid: Not initialized | Pathfinding Cache: 0 paths | Collision Checks: 0/frame | Type 2 Exploring: 0 | Type 2 Can See Destination: 0 | Wall Corrections: 0/frame
        </div>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Simulation state
        let agents = [];
        let walls = [];
        let doors = [];
        let fires = [];
        let destination = null;
        let isRunning = false;
        let animationId = null;
        let lastTime = 0;
        let simulationTime = 0;
        let frameCount = 0;
        let fps = 0;
        let lastFpsUpdate = 0;
        
        // Performance tracking
        let collisionChecksPerFrame = 0;
        let wallCorrectionsPerFrame = 0;
        let lastPathfindingTime = 0;
        
        // Wall drawing and preview
        let previewWall = null;
        let previewRectangle = null;
        let eraserRadius = 20;
        let mouseX = 0;
        let mouseY = 0;
        let mouseInCanvas = false;
        let lastEraseX = -1;
        let lastEraseY = -1;
        
        // UI state
        let currentMode = 'addAgent';
        let selectedAgentType = 1;
        let isDrawingWall = false;
        let isDrawingRectangle = false;
        let isErasing = false;
        let isCreatingDoor = false;
        let lastDoorX = 0;
        let lastDoorY = 0;
        let wallStartX = 0;
        let wallStartY = 0;
        let rectangleStartX = 0;
        let rectangleStartY = 0;
        
        // Parameters
        let maxSpeed = 1.5;
        let gridSize = 10;
        let pathfindingFreq = 1.0;
        let collisionRadius = 30;
        let collisionStrength = 0.8;
        let wallRepulsionStrength = 5.0;
        let wallRepulsionRange = 50;
        let visionConeDisplay = 80;
        let visionAngle = 90;
        
        // Visualization options
        let showGrid = false;
        let showPaths = true;
        let showVisionCones = false;
        let showCollisionCircles = false;
        let showCongestion = false;
        
        // Pathfinding
        let gridManager = null;
        let pathManager = null;
        
        // Grid manager for pathfinding
        class GridManager {
            constructor(width, height, cellSize) {
                this.width = width;
                this.height = height;
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = [];
                this.initializeGrid();
            }
            
            initializeGrid() {
                this.grid = [];
                for (let y = 0; y < this.rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        this.grid[y][x] = { blocked: false, cost: 1, congestion: 0 };
                    }
                }
            }
            
            markLineBlocked(x1, y1, x2, y2) {
                // Convert to grid coordinates
                const gx1 = Math.floor(x1 / this.cellSize);
                const gy1 = Math.floor(y1 / this.cellSize);
                const gx2 = Math.floor(x2 / this.cellSize);
                const gy2 = Math.floor(y2 / this.cellSize);
                
                // Use Bresenham's line algorithm to mark cells
                const dx = Math.abs(gx2 - gx1);
                const dy = Math.abs(gy2 - gy1);
                const sx = gx1 < gx2 ? 1 : -1;
                const sy = gy1 < gy2 ? 1 : -1;
                let err = dx - dy;
                
                let x = gx1;
                let y = gy1;
                
                while (true) {
                    // Mark the current cell and add thickness
                    this.markCellWithDirectionalThickness(x, y, x1, y1, x2, y2);
                    
                    if (x === gx2 && y === gy2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
            }
            
            markCellWithDirectionalThickness(gx, gy, x1, y1, x2, y2) {
                // Calculate wall direction
                const wallDx = x2 - x1;
                const wallDy = y2 - y1;
                const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                
                if (wallLength === 0) {
                    this.markCellBlocked(gx, gy);
                    return;
                }
                
                // Normalize wall direction
                const wallUnitX = wallDx / wallLength;
                const wallUnitY = wallDy / wallLength;
                
                // Determine if wall is more horizontal or vertical
                const isMoreHorizontal = Math.abs(wallUnitX) > Math.abs(wallUnitY);
                
                // Mark the center cell
                this.markCellBlocked(gx, gy);
                
                if (isMoreHorizontal) {
                    // For horizontal walls, add thickness vertically
                    this.markCellBlocked(gx, gy - 1); // Above
                    this.markCellBlocked(gx, gy + 1); // Below
                } else {
                    // For vertical walls, add thickness horizontally
                    this.markCellBlocked(gx - 1, gy); // Left
                    this.markCellBlocked(gx + 1, gy); // Right
                }
            }
            
            markCellBlocked(x, y) {
                if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                    this.grid[y][x].blocked = true;
                }
            }
            
            isBlocked(x, y) {
                if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) {
                    return true;
                }
                return this.grid[y][x].blocked;
            }
            
            worldToGrid(worldX, worldY) {
                return {
                    x: Math.floor(worldX / this.cellSize),
                    y: Math.floor(worldY / this.cellSize)
                };
            }
            
            gridToWorld(gridX, gridY) {
                return {
                    x: (gridX + 0.5) * this.cellSize,
                    y: (gridY + 0.5) * this.cellSize
                };
            }
            
            getNeighbors(x, y) {
                const neighbors = [];
                const directions = [
                    [-1, -1], [0, -1], [1, -1],
                    [-1,  0],          [1,  0],
                    [-1,  1], [0,  1], [1,  1]
                ];
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (!this.isBlocked(nx, ny)) {
                        // Calculate cost (diagonal moves cost more)
                        const cost = (dx !== 0 && dy !== 0) ? Math.sqrt(2) : 1;
                        neighbors.push({ x: nx, y: ny, cost });
                    }
                }
                
                return neighbors;
            }
            
            markCircleBlocked(centerX, centerY, radius) {
                // Convert center to grid coordinates
                const gridCenter = this.worldToGrid(centerX, centerY);
                const gridRadius = Math.ceil(radius / this.cellSize);
                
                // Mark all cells within the circle as blocked
                for (let y = gridCenter.y - gridRadius; y <= gridCenter.y + gridRadius; y++) {
                    for (let x = gridCenter.x - gridRadius; x <= gridCenter.x + gridRadius; x++) {
                        // Calculate distance from center
                        const dx = x - gridCenter.x;
                        const dy = y - gridCenter.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) * this.cellSize;
                        
                        // If within radius, mark as blocked
                        if (distance <= radius) {
                            this.markCellBlocked(x, y);
                        }
                    }
                }
            }
        }
        
        // Path manager with caching
        class PathManager {
            constructor() {
                this.cache = new Map();
                this.maxCacheSize = 1000;
            }
            
            getCacheKey(startX, startY, endX, endY) {
                return `${startX},${startY}-${endX},${endY}`;
            }
            
            getPath(startX, startY, endX, endY) {
                const key = this.getCacheKey(startX, startY, endX, endY);
                
                if (this.cache.has(key)) {
                    return this.cache.get(key);
                }
                
                const path = this.findPath(startX, startY, endX, endY);
                
                // Cache management
                if (this.cache.size >= this.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                
                this.cache.set(key, path);
                return path;
            }
            
            findPath(startX, startY, endX, endY) {
                if (!gridManager) return null;
                
                const startTime = performance.now();
                
                const start = gridManager.worldToGrid(startX, startY);
                const end = gridManager.worldToGrid(endX, endY);
                
                // Check if start or end is blocked
                if (gridManager.isBlocked(start.x, start.y) || gridManager.isBlocked(end.x, end.y)) {
                    lastPathfindingTime = performance.now() - startTime;
                    return null;
                }
                
                // A* algorithm
                const openSet = [{ ...start, f: 0, g: 0, h: 0, parent: null }];
                const closedSet = new Set();
                const openSetMap = new Map();
                openSetMap.set(`${start.x},${start.y}`, openSet[0]);
                
                while (openSet.length > 0) {
                    // Find node with lowest f score
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < current.f) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    // Remove current from open set
                    openSet.splice(currentIndex, 1);
                    openSetMap.delete(`${current.x},${current.y}`);
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check if we reached the goal
                    if (current.x === end.x && current.y === end.y) {
                        const path = [];
                        let node = current;
                        while (node) {
                            const worldPos = gridManager.gridToWorld(node.x, node.y);
                            path.unshift(worldPos);
                            node = node.parent;
                        }
                        lastPathfindingTime = performance.now() - startTime;
                        return path;
                    }
                    
                    // Check neighbors
                    const neighbors = gridManager.getNeighbors(current.x, current.y);
                    
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        
                        if (closedSet.has(neighborKey)) continue;
                        
                        const g = current.g + neighbor.cost;
                        const h = Math.sqrt(Math.pow(neighbor.x - end.x, 2) + Math.pow(neighbor.y - end.y, 2));
                        const f = g + h;
                        
                        const existingNode = openSetMap.get(neighborKey);
                        
                        if (!existingNode || g < existingNode.g) {
                            const node = {
                                x: neighbor.x,
                                y: neighbor.y,
                                f, g, h,
                                parent: current
                            };
                            
                            if (!existingNode) {
                                openSet.push(node);
                                openSetMap.set(neighborKey, node);
                            } else {
                                // Update existing node
                                existingNode.f = f;
                                existingNode.g = g;
                                existingNode.h = h;
                                existingNode.parent = current;
                            }
                        }
                    }
                }
                
                lastPathfindingTime = performance.now() - startTime;
                return null; // No path found
            }
            
            invalidateCache() {
                this.cache.clear();
            }
            
            getCacheSize() {
                return this.cache.size;
            }
        }
        
        // Initialize pathfinding
        function initializePathfinding() {
            gridManager = new GridManager(canvas.width, canvas.height, gridSize);
            pathManager = new PathManager();
            updatePathfinding();
        }
        
        // Update pathfinding grid when walls change
        function updatePathfinding() {
            if (!gridManager) return;
            
            gridManager.initializeGrid();
            
            // Mark all walls as blocked (including invisible fire walls)
            for (const wall of walls) {
                gridManager.markLineBlocked(wall.x1, wall.y1, wall.x2, wall.y2);
            }
            
            // Mark fire areas as blocked circles (double protection)
            for (const fire of fires) {
                gridManager.markCircleBlocked(fire.x, fire.y, fire.radius + 20); // Extra safety margin
            }
            
            if (pathManager) {
                pathManager.invalidateCache();
            }
        }
        
        // Wall class
        class Wall {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
            }
            
            draw(ctx) {
                // Skip drawing if this is an invisible wall
                if (this.isInvisible) {
                    return;
                }
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();
            }
        }
        
        // Door class - visual doors that don't block movement
        class Door {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
            }
            
            draw(ctx) {
                ctx.strokeStyle = '#00ffff'; // Teal color
                ctx.lineWidth = 6; // Slightly thicker than walls
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();
                
                // Add door frame effect
                ctx.strokeStyle = '#008888'; // Darker teal for frame
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // Destination class
        class Destination {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 35; // Bigger radius
            }
            
            draw(ctx) {
                // Draw green glowing circle edge (no fill)
                ctx.strokeStyle = '#00ff66';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ff66';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add inner glow
                ctx.shadowBlur = 6;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Reset shadow for text
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Draw white EXIT text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('EXIT', this.x, this.y);
            }
        }
        
        // Fire class
        class Fire {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 25; // Fire area radius
                this.repulsionRadius = 80; // How far agents will run from fire
                this.animationOffset = Math.random() * Math.PI * 2; // For flame animation
                this.invisibleWalls = []; // Track invisible walls created by this fire
                
                // Create invisible circular walls to block pathfinding
                this.createInvisibleWalls();
            }
            
            // Create invisible circular walls around the fire to block pathfinding
            createInvisibleWalls() {
                const segments = 24; // More segments for better circular coverage
                const wallRadius = this.radius + 15; // Larger radius to ensure no paths through fire
                
                for (let i = 0; i < segments; i++) {
                    const angle1 = (i / segments) * Math.PI * 2;
                    const angle2 = ((i + 1) / segments) * Math.PI * 2;
                    
                    const x1 = this.x + Math.cos(angle1) * wallRadius;
                    const y1 = this.y + Math.sin(angle1) * wallRadius;
                    const x2 = this.x + Math.cos(angle2) * wallRadius;
                    const y2 = this.y + Math.sin(angle2) * wallRadius;
                    
                    // Create invisible wall segment
                    const wall = new Wall(x1, y1, x2, y2);
                    wall.isInvisible = true; // Mark as invisible
                    this.invisibleWalls.push(wall);
                    walls.push(wall); // Add to global walls array
                }
                
                // Also create a solid circular barrier in the pathfinding grid
                if (gridManager) {
                    gridManager.markCircleBlocked(this.x, this.y, wallRadius + 5);
                }
            }
            
            // Remove invisible walls when fire is destroyed
            removeInvisibleWalls() {
                for (const wall of this.invisibleWalls) {
                    const index = walls.indexOf(wall);
                    if (index > -1) {
                        walls.splice(index, 1);
                    }
                }
                this.invisibleWalls = [];
            }
            
            draw(ctx) {
                const time = Date.now() * 0.003; // Animation speed
                
                // Draw multiple flame layers for realistic fire effect
                for (let i = 0; i < 3; i++) {
                    const layerRadius = this.radius - i * 3;
                    const flameHeight = layerRadius * (1.2 + Math.sin(time + this.animationOffset + i) * 0.3);
                    
                    // Create flame shape with multiple points
                    ctx.strokeStyle = i === 0 ? '#ff6600' : (i === 1 ? '#ff8800' : '#ffaa00');
                    ctx.lineWidth = 2 - i * 0.3;
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 8 - i * 2;
                    
                    ctx.beginPath();
                    
                    // Draw flame shape
                    const points = 8;
                    for (let j = 0; j <= points; j++) {
                        const angle = (j / points) * Math.PI * 2;
                        const variation = Math.sin(time * 2 + this.animationOffset + j + i) * 0.3;
                        const currentRadius = layerRadius * (0.8 + variation);
                        
                        const x = this.x + Math.cos(angle) * currentRadius;
                        const y = this.y + Math.sin(angle) * currentRadius * (j < points/2 ? 1 : 0.7); // Make flames taller at top
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Draw "FIRE" text in center
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FIRE', this.x, this.y);
            }
            
            // Check if a point is within the repulsion radius
            isInRepulsionRange(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.repulsionRadius;
            }
            
            // Get repulsion force for an agent
            getRepulsionForce(agentX, agentY) {
                const dx = agentX - this.x;
                const dy = agentY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0 || distance > this.repulsionRadius) {
                    return { x: 0, y: 0 };
                }
                
                // Stronger repulsion when closer to fire
                const strength = (this.repulsionRadius - distance) / this.repulsionRadius;
                const force = strength * 2.0; // Fire repulsion strength
                
                const normalizedX = dx / distance;
                const normalizedY = dy / distance;
                
                return {
                    x: normalizedX * force,
                    y: normalizedY * force
                };
            }
        }
        
        // Agent class
        class Agent {
            constructor(x, y, type = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = 8;
                this.maxSpeed = maxSpeed;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.spawnTime = Date.now(); // Track spawn time for escape time calculation
                
                // Enhanced collision avoidance
                this.personalSpace = 20;
                this.lookAheadTime = 2.0;
                this.collisionAvoidanceForce = { x: 0, y: 0 };
                this.separationForce = { x: 0, y: 0 };
                this.wallRepulsionForce = { x: 0, y: 0 };
                this.desiredVelocity = { x: 0, y: 0 };
                
                // Pathfinding
                this.currentPath = null;
                this.currentWaypoint = 0;
                this.lastPathRequest = 0;
                this.pathRequestInterval = pathfindingFreq * 1000;
                this.hasReachedDestination = false;
                
                // Type 2 specific properties
                this.isExploring = type === 2;
                this.canSeeDestination = false;
                this.destinationCheckTimer = 0;
                this.destinationCheckInterval = 500; // Check every 500ms
                this.randomTarget = null;
                this.randomTargetTimer = 0;
                this.randomTargetInterval = 3000; // Change target every 3 seconds
                
                 // Type 3 specific properties
                this.targetAgent = null; // The agent this follower is targeting
                this.followingDistance = 25; // Preferred distance to maintain from target
                this.targetSearchTimer = 0;
                this.targetSearchInterval = 1000; // Search for new target every 1 second
                this.lastTargetPosition = null;
                
                // Type 4 specific properties (Smart Follower)
                if (type === 4) {
                    this.targetAgent = null; // The Type 2 agent this smart follower is targeting
                    this.targetSearchTimer = 0;
                    this.targetSearchInterval = 1000; // Search for new target every 1 second
                    this.lastTargetPosition = null;
                }
                
                // Type 0 specific properties (Smart Agents)
                this.isSmartAgent = type === 0;
                this.stuckDetectionThreshold = 0.05; // Much lower speed threshold - only truly stopped agents
                this.stuckTimeThreshold = 3000; // Increased to 3 seconds before considering stuck
                this.explorationRadius = 60; // How far to explore when stuck
                this.explorationAngle = 0; // Current exploration direction
                this.explorationTimer = 0;
                this.explorationInterval = 1500; // How long to explore in one direction
                this.isExploringAroundObstacle = false;
                this.lastStuckPosition = null;
                this.avoidanceMemory = []; // Remember recent stuck positions
                this.memoryDuration = 5000; // How long to remember stuck positions
                
                // Line-of-sight system for Type 0 agents
                this.visibleWalls = []; // Walls this agent can see
                this.visibleFires = []; // Fires this agent can see
                this.visionRange = 200; // Increased vision range so they can see obstacles better
                this.lastVisionUpdate = 0;
                this.visionUpdateInterval = 500; // Update vision every 500ms
                this.knownObstacles = new Set(); // Track known obstacle IDs
                
                // Enhanced stuck detection for all agents
                this.stuckTimer = 0;
                this.lastPosition = { x: this.x, y: this.y };
                this.movementHistory = []; // Track recent positions
                this.historySize = 10;
                
                // Danger and death system
                this.dangerTimer = 0; // Time spent near fire
                this.dangerThreshold = 3000; // 3 seconds in milliseconds
                this.dangerDistance = 35; // Distance from fire considered dangerous
                this.isDead = false; // Death state
                this.deathTime = 0; // When the agent died
                
                // Escape system
                this.hasEscaped = false; // Escape state
                this.escapeTime = 0; // When the agent escaped
            }
            
            update(deltaTime) {
                // If agent is dead or escaped, don't update anything
                if (this.isDead || this.hasEscaped) {
                    return;
                }
                
                // Check if agent has reached the exit
                if (destination && this.distanceTo(destination.x, destination.y) < destination.radius) {
                    this.escape();
                    return;
                }
                
                // Check danger from fire
                this.updateDangerTimer(deltaTime);
                
                // If agent died from fire exposure, stop updating
                if (this.isDead) {
                    return;
                }
                
                // Reset forces
                this.collisionAvoidanceForce = { x: 0, y: 0 };
                this.separationForce = { x: 0, y: 0 };
                this.wallRepulsionForce = { x: 0, y: 0 };
                this.desiredVelocity = { x: 0, y: 0 };
                
                // Update navigation
                this.updateNavigation(deltaTime);
                
                // Apply enhanced collision avoidance
                this.applyEnhancedCollisionAvoidance();
                
                // Apply movement
                this.applyMovement(deltaTime);
                
                // Apply enhanced wall collision prevention
                this.enforceWallBoundaries();
                
                // Update angle for rendering
                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    this.angle = Math.atan2(this.vy, this.vx);
                }
                
                // Keep in bounds
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                
                // Check if stuck
                this.checkIfStuck(deltaTime);
            }
            
            updateNavigation(deltaTime) {
                // Update movement history for stuck detection
                this.updateMovementHistory();
                
                if (!destination) {
                    if (this.type === 2) {
                        this.exploreRandomly(deltaTime);
                    } else if (this.type === 3) {
                        this.followNearestType1Agent(deltaTime);
                    } else if (this.type === 4) {
                        this.followNearestType2AgentWithPathfinding(deltaTime);
                    } else if (this.type === 0) {
                        // Type 0 agents explore when no destination
                        this.exploreRandomly(deltaTime);
                    }
                    return;
                }
                
                if (this.type === 0) {
                    // Type 0: Smart Agent - enhanced stuck detection and obstacle avoidance
                    this.updateType0Navigation(deltaTime);
                } else if (this.type === 1) {
                    // Type 1: Random Explorer - A* to random targets, switches when destination visible
                    this.updateType2Navigation(deltaTime);
                } else if (this.type === 2) {
                    // Type 2: Informed Navigator - knows whole map, uses A* pathfinding
                    this.updateType1Navigation();
                } else if (this.type === 3) {
                    // Type 3: Follower - follows nearest Type 2 agent (Informed Navigator)
                    this.updateType3Navigation(deltaTime);
                } else if (this.type === 4) {
                    // Type 4: Smart Follower - uses A* to reach nearest Type 2 agent
                    this.updateType4Navigation(deltaTime);
                }
            }
            
            // Update danger timer based on proximity to fire
            updateDangerTimer(deltaTime) {
                let nearFire = false;
                
                // Check distance to all fires
                for (const fire of fires) {
                    const distance = this.distanceTo(fire.x, fire.y);
                    if (distance <= this.dangerDistance) {
                        nearFire = true;
                        break;
                    }
                }
                
                if (nearFire) {
                    // Increase danger timer
                    this.dangerTimer += deltaTime * 1000; // Convert to milliseconds
                    
                    // Check if agent should die
                    if (this.dangerTimer >= this.dangerThreshold) {
                        this.die();
                    }
                } else {
                    // Reset danger timer when away from fire
                    this.dangerTimer = 0;
                }
            }
            
            // Agent death
            die() {
                this.isDead = true;
                this.deathTime = Date.now();
                this.vx = 0; // Stop movement
                this.vy = 0;
            }
            
            // Agent escape
            escape() {
                this.hasEscaped = true;
                this.escapeTime = Date.now();
                this.escapeTimeDuration = (this.escapeTime - this.spawnTime) / 1000; // Duration in seconds
                this.vx = 0; // Stop movement
                this.vy = 0;
                this.hasReachedDestination = true;
            }
            
            updateType1Navigation() {
                const now = Date.now();
                
                // Request new path if needed
                if (!this.currentPath || 
                    now - this.lastPathRequest > this.pathRequestInterval ||
                    this.stuckTimer > 3000) {
                    
                    this.requestNewPath(destination.x, destination.y);
                    this.lastPathRequest = now;
                    this.stuckTimer = 0;
                }
                
                // Follow current path
                this.followPath();
            }
            
            updateType2Navigation(deltaTime) {
                this.destinationCheckTimer += deltaTime * 1000;
                
                // Check if destination is visible (less frequently for performance)
                if (this.destinationCheckTimer > this.destinationCheckInterval) {
                    this.canSeeDestination = this.hasInfiniteLineOfSightToDestination();
                    this.destinationCheckTimer = 0;
                    
                    // If we can see the destination, switch to direct pathfinding
                    if (this.canSeeDestination && this.isExploring) {
                        this.isExploring = false;
                        this.currentPath = null; // Clear current exploration path
                        this.requestNewPath(destination.x, destination.y);
                        return;
                    }
                }
                
                if (this.canSeeDestination && !this.isExploring) {
                    // Continue following path to destination
                    this.followPath();
                    
                    // Check if we need a new path to destination
                    const now = Date.now();
                    if (!this.currentPath || 
                        now - this.lastPathRequest > this.pathRequestInterval ||
                        this.stuckTimer > 3000) {
                        
                        this.requestNewPath(destination.x, destination.y);
                        this.lastPathRequest = now;
                        this.stuckTimer = 0;
                    }
                } else {
                    // Continue exploring with A* pathfinding to random targets
                    this.isExploring = true;
                    this.exploreWithPathfinding(deltaTime);
                }
            }
            
            exploreWithPathfinding(deltaTime) {
                this.randomTargetTimer += deltaTime * 1000;
                
                // Generate new random target if needed
                if (!this.randomTarget || this.randomTargetTimer > this.randomTargetInterval) {
                    this.generateRandomTarget();
                    this.randomTargetTimer = 0;
                }
                
                // Request path to random target
                const now = Date.now();
                if (!this.currentPath || 
                    now - this.lastPathRequest > this.pathRequestInterval ||
                    this.stuckTimer > 3000) {
                    
                    this.requestNewPath(this.randomTarget.x, this.randomTarget.y);
                    this.lastPathRequest = now;
                    this.stuckTimer = 0;
                }
                
                // Follow current path
                this.followPath();
            }
            
            generateRandomTarget() {
                const margin = 50;
                this.randomTarget = {
                    x: margin + Math.random() * (canvas.width - 2 * margin),
                    y: margin + Math.random() * (canvas.height - 2 * margin)
                };
            }
            
            exploreRandomly(deltaTime) {
                this.randomTargetTimer += deltaTime * 1000;
                
                if (!this.randomTarget || this.randomTargetTimer > this.randomTargetInterval) {
                    this.generateRandomTarget();
                    this.randomTargetTimer = 0;
                }
                
                if (this.randomTarget) {
                    const dx = this.randomTarget.x - this.x;
                    const dy = this.randomTarget.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 10) {
                        this.desiredVelocity.x = (dx / distance) * this.maxSpeed;
                        this.desiredVelocity.y = (dy / distance) * this.maxSpeed;
                    }
                }
            }
            
            hasInfiniteLineOfSightToDestination() {
                if (!destination) return false;
                
                // Calculate direction to destination
                const dx = destination.x - this.x;
                const dy = destination.y - this.y;
                const angleToDestination = Math.atan2(dy, dx);
                
                // Calculate the difference between agent's facing direction and destination direction
                let angleDiff = angleToDestination - this.angle;
                
                // Normalize angle difference to [-π, π]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                // Check if destination is within the vision cone
                const halfVisionAngle = (visionAngle * Math.PI / 180) / 2;
                return Math.abs(angleDiff) <= halfVisionAngle;
            }
            
            requestNewPath(targetX, targetY) {
                if (!pathManager) return;
                
                this.currentPath = pathManager.getPath(this.x, this.y, targetX, targetY);
                this.currentWaypoint = 0;
                
                // Skip the first waypoint if it's too close to current position
                if (this.currentPath && this.currentPath.length > 1) {
                    const firstWaypoint = this.currentPath[0];
                    const distToFirst = this.distanceTo(firstWaypoint.x, firstWaypoint.y);
                    if (distToFirst < 15) {
                        this.currentWaypoint = 1;
                    }
                }
            }
            
            followPath() {
                if (!this.currentPath || this.currentWaypoint >= this.currentPath.length) {
                    return;
                }
                
                const waypoint = this.currentPath[this.currentWaypoint];
                const dx = waypoint.x - this.x;
                const dy = waypoint.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if we've reached the current waypoint
                if (distance < 15) {
                    this.currentWaypoint++;
                    
                    // Check if we've reached the final destination
                    if (this.currentWaypoint >= this.currentPath.length) {
                        if (destination && this.distanceTo(destination.x, destination.y) < 25) {
                            this.hasReachedDestination = true;
                        }
                        return;
                    }
                    
                    // Move to next waypoint
                    const nextWaypoint = this.currentPath[this.currentWaypoint];
                    const nextDx = nextWaypoint.x - this.x;
                    const nextDy = nextWaypoint.y - this.y;
                    const nextDistance = Math.sqrt(nextDx * nextDx + nextDy * nextDy);
                    
                    if (nextDistance > 0) {
                        this.desiredVelocity.x = (nextDx / nextDistance) * this.maxSpeed;
                        this.desiredVelocity.y = (nextDy / nextDistance) * this.maxSpeed;
                    }
                } else {
                    // Move towards current waypoint
                    this.desiredVelocity.x = (dx / distance) * this.maxSpeed;
                    this.desiredVelocity.y = (dy / distance) * this.maxSpeed;
                }
            }
            
            // Type 3 Follower Methods
            followNearestType1Agent(deltaTime) {
                this.targetSearchTimer += deltaTime * 1000;
                
                // Search for nearest Type 1 agent periodically
                if (!this.targetAgent || this.targetSearchTimer > this.targetSearchInterval) {
                    this.targetAgent = this.findNearestType1Agent();
                    this.targetSearchTimer = 0;
                }
                
                if (this.targetAgent) {
                    const dx = this.targetAgent.x - this.x;
                    const dy = this.targetAgent.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Follow at preferred distance
                    if (distance > this.followingDistance + 10) {
                        // Too far, move closer
                        this.desiredVelocity.x = (dx / distance) * this.maxSpeed;
                        this.desiredVelocity.y = (dy / distance) * this.maxSpeed;
                    } else if (distance < this.followingDistance - 10) {
                        // Too close, move away
                        this.desiredVelocity.x = -(dx / distance) * this.maxSpeed * 0.5;
                        this.desiredVelocity.y = -(dy / distance) * this.maxSpeed * 0.5;
                    } else {
                        // At good distance, match target's velocity
                        this.desiredVelocity.x = this.targetAgent.vx * 0.8;
                        this.desiredVelocity.y = this.targetAgent.vy * 0.8;
                    }
                }
            }
            
            updateType3Navigation(deltaTime) {
                this.targetSearchTimer += deltaTime * 1000;
                
                // Search for nearest Type 2 agent periodically
                if (!this.targetAgent || this.targetSearchTimer > this.targetSearchInterval) {
                    this.targetAgent = this.findNearestType2Agent();
                    this.targetSearchTimer = 0;
                }
                
                if (this.targetAgent) {
                    // Follow the target agent, but also consider destination
                    const distToTarget = this.distanceTo(this.targetAgent.x, this.targetAgent.y);
                    const distToDestination = destination ? this.distanceTo(destination.x, destination.y) : Infinity;
                    
                    // If very close to destination, prioritize destination
                    if (distToDestination < 50) {
                        const dx = destination.x - this.x;
                        const dy = destination.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            this.desiredVelocity.x = (dx / distance) * this.maxSpeed;
                            this.desiredVelocity.y = (dy / distance) * this.maxSpeed;
                        }
                    } else {
                        // Follow the target agent
                        const dx = this.targetAgent.x - this.x;
                        const dy = this.targetAgent.y - this.y;
                        
                        if (distToTarget > this.followingDistance + 10) {
                            // Too far, move closer
                            this.desiredVelocity.x = (dx / distToTarget) * this.maxSpeed;
                            this.desiredVelocity.y = (dy / distToTarget) * this.maxSpeed;
                        } else if (distToTarget < this.followingDistance - 10) {
                            // Too close, move away
                            this.desiredVelocity.x = -(dx / distToTarget) * this.maxSpeed * 0.5;
                            this.desiredVelocity.y = -(dy / distToTarget) * this.maxSpeed * 0.5;
                        } else {
                            // At good distance, match target's velocity
                            this.desiredVelocity.x = this.targetAgent.vx * 0.8;
                            this.desiredVelocity.y = this.targetAgent.vy * 0.8;
                        }
                    }
                } else {
                    // No Type 1 agent found, move towards destination if available
                    if (destination) {
                        const dx = destination.x - this.x;
                        const dy = destination.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            this.desiredVelocity.x = (dx / distance) * this.maxSpeed;
                            this.desiredVelocity.y = (dy / distance) * this.maxSpeed;
                        }
                    }
                }
            }
            
            findNearestType2Agent() {
                let nearestAgent = null;
                let nearestDistance = Infinity;
                
                for (const agent of agents) {
                    if (agent.type === 2 && agent !== this && !agent.isDead) { // Skip dead agents
                        const distance = this.distanceTo(agent.x, agent.y);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestAgent = agent;
                        }
                    }
                }
                
                return nearestAgent;
            }
            
            // Type 4 Smart Follower Methods
            updateType4Navigation(deltaTime) {
                this.targetSearchTimer += deltaTime * 1000;
                
                // Search for nearest Type 2 agent periodically
                if (!this.targetAgent || this.targetSearchTimer > this.targetSearchInterval) {
                    this.targetAgent = this.findNearestType2Agent();
                    this.targetSearchTimer = 0;
                }
                
                if (this.targetAgent) {
                    // Use A* pathfinding to reach the Type 2 agent's current location
                    const now = Date.now();
                    
                    // Request new path if needed or if target has moved significantly
                    if (!this.currentPath || 
                        now - this.lastPathRequest > this.pathRequestInterval ||
                        this.stuckTimer > 3000 ||
                        this.hasTargetMovedSignificantly()) {
                        
                        this.requestNewPath(this.targetAgent.x, this.targetAgent.y);
                        this.lastPathRequest = now;
                        this.stuckTimer = 0;
                        this.lastTargetPosition = { x: this.targetAgent.x, y: this.targetAgent.y };
                    }
                    
                    // Follow current path
                    this.followPath();
                } else {
                    // No Type 2 agent found, move towards destination if available
                    if (destination) {
                        const now = Date.now();
                        if (!this.currentPath || 
                            now - this.lastPathRequest > this.pathRequestInterval ||
                            this.stuckTimer > 3000) {
                            
                            this.requestNewPath(destination.x, destination.y);
                            this.lastPathRequest = now;
                            this.stuckTimer = 0;
                        }
                        this.followPath();
                    }
                }
            }
            
            followNearestType2AgentWithPathfinding(deltaTime) {
                this.targetSearchTimer += deltaTime * 1000;
                
                // Search for nearest Type 2 agent periodically
                if (!this.targetAgent || this.targetSearchTimer > this.targetSearchInterval) {
                    this.targetAgent = this.findNearestType2Agent();
                    this.targetSearchTimer = 0;
                }
                
                if (this.targetAgent) {
                    // Use A* pathfinding to reach the Type 2 agent's current location
                    const now = Date.now();
                    
                    // Request new path if needed or if target has moved significantly
                    if (!this.currentPath || 
                        now - this.lastPathRequest > this.pathRequestInterval ||
                        this.stuckTimer > 3000 ||
                        this.hasTargetMovedSignificantly()) {
                        
                        this.requestNewPath(this.targetAgent.x, this.targetAgent.y);
                        this.lastPathRequest = now;
                        this.stuckTimer = 0;
                        this.lastTargetPosition = { x: this.targetAgent.x, y: this.targetAgent.y };
                    }
                    
                    // Follow current path
                    this.followPath();
                }
            }
            
            hasTargetMovedSignificantly() {
                if (!this.targetAgent || !this.lastTargetPosition) {
                    return true;
                }
                
                const dx = this.targetAgent.x - this.lastTargetPosition.x;
                const dy = this.targetAgent.y - this.lastTargetPosition.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance > 30; // Replan if target moved more than 30 pixels
            }
            
            // Type 0 Smart Agent Methods
            updateMovementHistory() {
                // Add current position to history
                this.movementHistory.push({ x: this.x, y: this.y, time: Date.now() });
                
                // Keep only recent history
                if (this.movementHistory.length > this.historySize) {
                    this.movementHistory.shift();
                }
                
                // Clean old avoidance memory
                const now = Date.now();
                this.avoidanceMemory = this.avoidanceMemory.filter(
                    memory => now - memory.time < this.memoryDuration
                );
            }
            
            updateType0Navigation(deltaTime) {
                const now = Date.now();
                
                // Update vision periodically
                if (now - this.lastVisionUpdate > this.visionUpdateInterval) {
                    this.updateVision();
                    this.lastVisionUpdate = now;
                }
                
                // Check if stuck (only after being stuck for 3+ seconds)
                const isStuck = this.detectStuckState(deltaTime);
                
                // Only change pathing if truly stuck for more than 3 seconds
                if (isStuck && this.stuckTimer > 3000) {
                    if (!this.isExploringAroundObstacle) {
                        // Start exploring around obstacle
                        this.startObstacleExploration();
                    } else {
                        // Continue exploration
                        this.continueObstacleExploration(deltaTime);
                    }
                } else if (this.isExploringAroundObstacle && !isStuck) {
                    // Stop exploring if no longer stuck
                    this.isExploringAroundObstacle = false;
                    this.explorationTimer = 0;
                    // Clear current path to force a fresh path calculation
                    this.currentPath = null;
                    // Resume normal pathfinding
                    this.performType0Navigation();
                } else if (!this.isExploringAroundObstacle) {
                    // Normal pathfinding behavior with visible obstacles only
                    this.performType0Navigation();
                } else {
                    // Continue exploration
                    this.continueObstacleExploration(deltaTime);
                }
            }
            
            // Update vision system for Type 0 agents
            updateVision() {
                const previousObstacleCount = this.knownObstacles.size;
                
                // Clear current visible obstacles
                this.visibleWalls = [];
                this.visibleFires = [];
                
                // Check walls within vision range
                for (let i = 0; i < walls.length; i++) {
                    const wall = walls[i];
                    if (this.canSeeWall(wall)) {
                        this.visibleWalls.push(wall);
                        this.knownObstacles.add(`wall_${i}`);
                    }
                }
                
                // Check fires within vision range
                for (let i = 0; i < fires.length; i++) {
                    const fire = fires[i];
                    if (this.canSeeFire(fire)) {
                        this.visibleFires.push(fire);
                        this.knownObstacles.add(`fire_${i}`);
                    }
                }
                
                // If new obstacles discovered, update path
                if (this.knownObstacles.size > previousObstacleCount) {
                    this.currentPath = null; // Force path recalculation
                }
            }
            
            // Check if agent can see a wall (not blocked by other walls)
            canSeeWall(wall) {
                // Check if wall is within vision range
                const wallMidX = (wall.x1 + wall.x2) / 2;
                const wallMidY = (wall.y1 + wall.y2) / 2;
                const distanceToWall = this.distanceTo(wallMidX, wallMidY);
                
                if (distanceToWall > this.visionRange) {
                    return false;
                }
                
                // Check line of sight to wall (not blocked by other visible walls)
                return this.hasLineOfSight(this.x, this.y, wallMidX, wallMidY, wall);
            }
            
            // Check if agent can see a fire (not blocked by walls)
            canSeeFire(fire) {
                const distanceToFire = this.distanceTo(fire.x, fire.y);
                
                if (distanceToFire > this.visionRange) {
                    return false;
                }
                
                // Check line of sight to fire
                return this.hasLineOfSight(this.x, this.y, fire.x, fire.y);
            }
            
            // Check line of sight between two points
            hasLineOfSight(x1, y1, x2, y2, excludeWall = null) {
                // Check if line of sight is blocked by any visible walls
                for (const wall of this.visibleWalls) {
                    if (wall === excludeWall) continue;
                    
                    if (this.lineIntersectsWall(x1, y1, x2, y2, wall)) {
                        return false;
                    }
                }
                
                // Also check against all walls for initial vision (when visibleWalls is empty)
                if (this.visibleWalls.length === 0) {
                    for (const wall of walls) {
                        if (wall === excludeWall || wall.isInvisible) continue;
                        
                        if (this.lineIntersectsWall(x1, y1, x2, y2, wall)) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            // Check if a line intersects with a wall
            lineIntersectsWall(x1, y1, x2, y2, wall) {
                // Line-line intersection algorithm
                const denom = (x1 - x2) * (wall.y1 - wall.y2) - (y1 - y2) * (wall.x1 - wall.x2);
                
                if (Math.abs(denom) < 0.0001) {
                    return false; // Lines are parallel
                }
                
                const t = ((x1 - wall.x1) * (wall.y1 - wall.y2) - (y1 - wall.y1) * (wall.x1 - wall.x2)) / denom;
                const u = -((x1 - x2) * (y1 - wall.y1) - (y1 - y2) * (x1 - wall.x1)) / denom;
                
                return t >= 0 && t <= 1 && u >= 0 && u <= 1;
            }
            
            // Type 0 specific pathfinding using only visible obstacles
            performType0Navigation() {
                const now = Date.now();
                
                // For Type 0 agents, only request new path if they don't have one yet
                // Do NOT automatically recalculate paths based on time intervals
                if (!this.currentPath) {
                    this.requestType0Path(destination.x, destination.y);
                    this.lastPathRequest = now;
                }
                
                // Follow current path
                this.followPath();
            }
            
            // Request path using only visible obstacles
            requestType0Path(targetX, targetY) {
                if (!pathManager || !gridManager) return;
                
                // Create a temporary grid manager with only visible obstacles
                // Type 0 agents should only avoid obstacles they can see
                const tempGrid = new GridManager(canvas.width, canvas.height, gridSize);
                
                // Add only visible walls to the grid
                for (const wall of this.visibleWalls) {
                    tempGrid.markLineBlocked(wall.x1, wall.y1, wall.x2, wall.y2);
                }
                
                // Add only visible fires to the grid
                for (const fire of this.visibleFires) {
                    tempGrid.markCircleBlocked(fire.x, fire.y, fire.radius + 20);
                }
                
                // Use temporary pathfinding with visible obstacles only
                this.currentPath = this.findPathWithGrid(tempGrid, this.x, this.y, targetX, targetY);
                this.currentWaypoint = 0;
                
                // Skip the first waypoint if it's too close to current position
                if (this.currentPath && this.currentPath.length > 1) {
                    const firstWaypoint = this.currentPath[0];
                    const distToFirst = this.distanceTo(firstWaypoint.x, firstWaypoint.y);
                    if (distToFirst < 15) {
                        this.currentWaypoint = 1;
                    }
                }
            }
            
            // Custom pathfinding using a specific grid
            findPathWithGrid(grid, startX, startY, endX, endY) {
                const startTime = performance.now();
                
                const start = grid.worldToGrid(startX, startY);
                const end = grid.worldToGrid(endX, endY);
                
                // Check if start or end is blocked
                if (grid.isBlocked(start.x, start.y) || grid.isBlocked(end.x, end.y)) {
                    lastPathfindingTime = performance.now() - startTime;
                    return null;
                }
                
                // A* algorithm
                const openSet = [{ ...start, f: 0, g: 0, h: 0, parent: null }];
                const closedSet = new Set();
                const openSetMap = new Map();
                openSetMap.set(`${start.x},${start.y}`, openSet[0]);
                
                while (openSet.length > 0) {
                    // Find node with lowest f score
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < current.f) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    // Remove current from open set
                    openSet.splice(currentIndex, 1);
                    openSetMap.delete(`${current.x},${current.y}`);
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check if we reached the goal
                    if (current.x === end.x && current.y === end.y) {
                        const path = [];
                        let node = current;
                        while (node) {
                            const worldPos = grid.gridToWorld(node.x, node.y);
                            path.unshift(worldPos);
                            node = node.parent;
                        }
                        lastPathfindingTime = performance.now() - startTime;
                        return path;
                    }
                    
                    // Check neighbors
                    const neighbors = grid.getNeighbors(current.x, current.y);
                    
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        
                        if (closedSet.has(neighborKey)) continue;
                        
                        const g = current.g + neighbor.cost;
                        const h = Math.sqrt(Math.pow(neighbor.x - end.x, 2) + Math.pow(neighbor.y - end.y, 2));
                        const f = g + h;
                        
                        const existingNode = openSetMap.get(neighborKey);
                        
                        if (!existingNode || g < existingNode.g) {
                            const node = {
                                x: neighbor.x,
                                y: neighbor.y,
                                f, g, h,
                                parent: current
                            };
                            
                            if (!existingNode) {
                                openSet.push(node);
                                openSetMap.set(neighborKey, node);
                            } else {
                                // Update existing node
                                existingNode.f = f;
                                existingNode.g = g;
                                existingNode.h = h;
                                existingNode.parent = current;
                            }
                        }
                    }
                }
                
                lastPathfindingTime = performance.now() - startTime;
                return null; // No path found
            }
            
            detectStuckState(deltaTime) {
                // Calculate current speed
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                // Only consider stuck if agent is essentially motionless
                if (currentSpeed < this.stuckDetectionThreshold) {
                    this.stuckTimer += deltaTime * 1000;
                } else {
                    this.stuckTimer = 0;
                    return false;
                }
                
                // Consider stuck only if motionless for the full threshold time AND near an obstacle
                if (this.stuckTimer > this.stuckTimeThreshold) {
                    // Additional check: are we near fire or walls?
                    const nearObstacle = this.isNearObstacle();
                    if (nearObstacle) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Check if agent is currently blocked by obstacles in their immediate path
            isCurrentlyBlocked() {
                if (!destination) return false;
                
                // Check if there's a direct obstacle blocking the path to destination
                const dx = destination.x - this.x;
                const dy = destination.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0) return false;
                
                // Normalize direction
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                // Check a short distance ahead (about 2-3 agent radii)
                const checkDistance = this.radius * 3;
                const checkX = this.x + dirX * checkDistance;
                const checkY = this.y + dirY * checkDistance;
                
                // For Type 0 agents, only check visible obstacles
                if (this.type === 0) {
                    // Check if blocked by visible fire
                    for (const fire of this.visibleFires) {
                        const distToFire = this.distanceTo(fire.x, fire.y);
                        const checkDistToFire = Math.sqrt((checkX - fire.x) ** 2 + (checkY - fire.y) ** 2);
                        if (checkDistToFire < fire.radius + this.radius + 10) {
                            return true;
                        }
                    }
                    
                    // Check if blocked by visible walls
                    for (const wall of this.visibleWalls) {
                        if (this.lineIntersectsWall(this.x, this.y, checkX, checkY, wall)) {
                            return true;
                        }
                    }
                } else {
                    // For other agent types, check all obstacles
                    // Check if blocked by fire
                    for (const fire of fires) {
                        const checkDistToFire = Math.sqrt((checkX - fire.x) ** 2 + (checkY - fire.y) ** 2);
                        if (checkDistToFire < fire.radius + this.radius + 10) {
                            return true;
                        }
                    }
                    
                    // Check if blocked by walls
                    for (const wall of walls) {
                        if (this.lineIntersectsWall(this.x, this.y, checkX, checkY, wall)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            isNearObstacle() {
                // For Type 0 agents, only check visible obstacles
                if (this.type === 0) {
                    // Check if near visible fire
                    for (const fire of this.visibleFires) {
                        const distance = this.distanceTo(fire.x, fire.y);
                        if (distance < fire.radius + 40) {
                            return true;
                        }
                    }
                    
                    // Check if near visible walls
                    for (const wall of this.visibleWalls) {
                        const distance = this.distanceToWall(wall);
                        if (distance < 30) {
                            return true;
                        }
                    }
                } else {
                    // For other agent types, check all obstacles
                    // Check if near fire
                    for (const fire of fires) {
                        const distance = this.distanceTo(fire.x, fire.y);
                        if (distance < fire.radius + 40) {
                            return true;
                        }
                    }
                    
                    // Check if near walls
                    for (const wall of walls) {
                        const distance = this.distanceToWall(wall);
                        if (distance < 30) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            startObstacleExploration() {
                this.isExploringAroundObstacle = true;
                this.explorationTimer = 0;
                
                // Remember this stuck position
                this.lastStuckPosition = { x: this.x, y: this.y };
                this.avoidanceMemory.push({
                    x: this.x,
                    y: this.y,
                    time: Date.now()
                });
                
                // Choose exploration direction away from obstacles
                this.explorationAngle = this.findBestExplorationDirection();
            }
            
            findBestExplorationDirection() {
                const numDirections = 8;
                let bestAngle = 0;
                let bestScore = -Infinity;
                
                for (let i = 0; i < numDirections; i++) {
                    const angle = (i / numDirections) * Math.PI * 2;
                    const score = this.evaluateDirection(angle);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestAngle = angle;
                    }
                }
                
                return bestAngle;
            }
            
            evaluateDirection(angle) {
                const testDistance = this.explorationRadius;
                const testX = this.x + Math.cos(angle) * testDistance;
                const testY = this.y + Math.sin(angle) * testDistance;
                
                let score = 100; // Base score
                
                // For Type 0 agents, only consider visible obstacles
                if (this.type === 0) {
                    // Penalize directions toward visible fire
                    for (const fire of this.visibleFires) {
                        const distToFire = Math.sqrt((testX - fire.x) ** 2 + (testY - fire.y) ** 2);
                        if (distToFire < fire.radius + 50) {
                            score -= 200;
                        }
                    }
                    
                    // Penalize directions toward visible walls
                    for (const wall of this.visibleWalls) {
                        const distToWall = this.pointDistanceToWall(testX, testY, wall);
                        if (distToWall < 30) {
                            score -= 150;
                        }
                    }
                } else {
                    // For other agent types, consider all obstacles
                    // Penalize directions toward fire
                    for (const fire of fires) {
                        const distToFire = Math.sqrt((testX - fire.x) ** 2 + (testY - fire.y) ** 2);
                        if (distToFire < fire.radius + 50) {
                            score -= 200;
                        }
                    }
                    
                    // Penalize directions toward walls
                    for (const wall of walls) {
                        const distToWall = this.pointDistanceToWall(testX, testY, wall);
                        if (distToWall < 30) {
                            score -= 150;
                        }
                    }
                }
                
                // Penalize directions toward remembered stuck positions
                for (const memory of this.avoidanceMemory) {
                    const distToMemory = Math.sqrt((testX - memory.x) ** 2 + (testY - memory.y) ** 2);
                    if (distToMemory < 40) {
                        score -= 100;
                    }
                }
                
                // Bonus for directions toward destination
                if (destination) {
                    const destAngle = Math.atan2(destination.y - this.y, destination.x - this.x);
                    const angleDiff = Math.abs(angle - destAngle);
                    const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                    score += (Math.PI - normalizedDiff) * 30;
                }
                
                return score;
            }
            
            continueObstacleExploration(deltaTime) {
                this.explorationTimer += deltaTime * 1000;
                
                // Move in exploration direction
                this.desiredVelocity.x = Math.cos(this.explorationAngle) * this.maxSpeed;
                this.desiredVelocity.y = Math.sin(this.explorationAngle) * this.maxSpeed;
                
                // Check if we should stop exploring
                if (this.explorationTimer > this.explorationInterval) {
                    // Check if we're clear of obstacles
                    if (!this.isNearObstacle()) {
                        this.isExploringAroundObstacle = false;
                        this.explorationTimer = 0;
                    } else {
                        // Try a new direction
                        this.explorationAngle = this.findBestExplorationDirection();
                        this.explorationTimer = 0;
                    }
                }
            }
            
            performNormalNavigation() {
                const now = Date.now();
                
                // Request new path if needed
                if (!this.currentPath || 
                    now - this.lastPathRequest > this.pathRequestInterval ||
                    this.stuckTimer > 3000) {
                    
                    this.requestNewPath(destination.x, destination.y);
                    this.lastPathRequest = now;
                    this.stuckTimer = 0;
                }
                
                // Follow current path
                this.followPath();
            }
            
            distanceToWall(wall) {
                return this.distanceToLineSegment(this.x, this.y, wall.x1, wall.y1, wall.x2, wall.y2);
            }
            
            pointDistanceToWall(x, y, wall) {
                // Calculate distance from point to wall line segment
                const A = x - wall.x1;
                const B = y - wall.y1;
                const C = wall.x2 - wall.x1;
                const D = wall.y2 - wall.y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));
                
                const xx = wall.x1 + param * C;
                const yy = wall.y1 + param * D;
                
                const dx = x - xx;
                const dy = y - yy;
                
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            applyEnhancedCollisionAvoidance() {
                // Apply collision avoidance with other agents
                this.calculateCollisionAvoidance();
                
                // Apply separation force
                this.calculateSeparation();
                
                // Apply enhanced wall avoidance
                this.addWallRepulsion();
                
                // Combine all forces with desired velocity
                const steeringForceX = this.desiredVelocity.x - this.vx;
                const steeringForceY = this.desiredVelocity.y - this.vy;
                
                // Apply forces with different weights
                const totalForceX = steeringForceX * 0.7 + 
                                  this.collisionAvoidanceForce.x * collisionStrength + 
                                  this.separationForce.x * 0.5 + 
                                  this.wallRepulsionForce.x * 0.7; // Reduced from 1.0
                
                const totalForceY = steeringForceY * 0.7 + 
                                  this.collisionAvoidanceForce.y * collisionStrength + 
                                  this.separationForce.y * 0.5 + 
                                  this.wallRepulsionForce.y * 0.7; // Reduced from 1.0
                
                // Apply acceleration limits
                const maxAcceleration = this.maxSpeed * 2;
                const acceleration = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
                
                if (acceleration > maxAcceleration) {
                    const scale = maxAcceleration / acceleration;
                    this.vx += totalForceX * scale * 0.1;
                    this.vy += totalForceY * scale * 0.1;
                } else {
                    this.vx += totalForceX * 0.1;
                    this.vy += totalForceY * 0.1;
                }
            }
            
            calculateCollisionAvoidance() {
                const avoidanceRadius = collisionRadius;
                
                for (const other of agents) {
                    if (other === this || other.isDead || other.hasEscaped) continue; // Skip dead and escaped agents
                    
                    collisionChecksPerFrame++;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < avoidanceRadius && distance > 0) {
                        // Predict future collision
                        const relativeVelocityX = other.vx - this.vx;
                        const relativeVelocityY = other.vy - this.vy;
                        
                        // Time to closest approach
                        const timeToClosest = -(dx * relativeVelocityX + dy * relativeVelocityY) / 
                                            (relativeVelocityX * relativeVelocityX + relativeVelocityY * relativeVelocityY + 0.001);
                        
                        if (timeToClosest > 0 && timeToClosest < this.lookAheadTime) {
                            // Predict positions at closest approach
                            const futureX = this.x + this.vx * timeToClosest;
                            const futureY = this.y + this.vy * timeToClosest;
                            const otherFutureX = other.x + other.vx * timeToClosest;
                            const otherFutureY = other.y + other.vy * timeToClosest;
                            
                            const futureDx = otherFutureX - futureX;
                            const futureDy = otherFutureY - futureY;
                            const futureDistance = Math.sqrt(futureDx * futureDx + futureDy * futureDy);
                            
                            // If collision predicted, apply avoidance force
                            if (futureDistance < this.radius + other.radius + 5) {
                                const avoidanceStrength = (avoidanceRadius - distance) / avoidanceRadius;
                                const urgency = Math.max(0, 1 - timeToClosest / this.lookAheadTime);
                                
                                // Calculate avoidance direction (perpendicular to relative velocity)
                                let avoidX, avoidY;
                                if (Math.abs(relativeVelocityX) > 0.1 || Math.abs(relativeVelocityY) > 0.1) {
                                    // Perpendicular to relative velocity
                                    avoidX = -relativeVelocityY;
                                    avoidY = relativeVelocityX;
                                } else {
                                    // Direct separation if no relative velocity
                                    avoidX = -dx;
                                    avoidY = -dy;
                                }
                                
                                const avoidLength = Math.sqrt(avoidX * avoidX + avoidY * avoidY);
                                if (avoidLength > 0) {
                                    avoidX /= avoidLength;
                                    avoidY /= avoidLength;
                                    
                                    const force = avoidanceStrength * urgency * 2.0;
                                    this.collisionAvoidanceForce.x += avoidX * force;
                                    this.collisionAvoidanceForce.y += avoidY * force;
                                }
                            }
                        }
                        
                        // Also apply immediate separation if too close
                        if (distance < this.radius + other.radius + 10) {
                            const separationStrength = (this.radius + other.radius + 10 - distance) / 10;
                            this.collisionAvoidanceForce.x -= (dx / distance) * separationStrength * 1.5;
                            this.collisionAvoidanceForce.y -= (dy / distance) * separationStrength * 1.5;
                        }
                    }
                }
            }
            
            calculateSeparation() {
                let separationX = 0;
                let separationY = 0;
                let neighborCount = 0;
                
                for (const other of agents) {
                    if (other === this || other.isDead || other.hasEscaped) continue; // Skip dead and escaped agents
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.personalSpace && distance > 0) {
                        // Weight by inverse distance
                        const weight = 1.0 / distance;
                        separationX -= (dx / distance) * weight;
                        separationY -= (dy / distance) * weight;
                        neighborCount++;
                    }
                }
                
                if (neighborCount > 0) {
                    this.separationForce.x = separationX / neighborCount;
                    this.separationForce.y = separationY / neighborCount;
                }
            }
            
            addWallRepulsion() {
                this.wallRepulsionForce = { x: 0, y: 0 };
                
                const maxRepulsionDistance = wallRepulsionRange; // Use the slider value
                const minRepulsionDistance = 4;  // Reduced for smoother close-range behavior
                
                for (const wall of walls) {
                    const distance = this.distanceToLineSegment(this.x, this.y, wall.x1, wall.y1, wall.x2, wall.y2);
                    
                    if (distance < maxRepulsionDistance) {
                        const closest = this.closestPointOnLineSegment(this.x, this.y, wall.x1, wall.y1, wall.x2, wall.y2);
                        const dx = this.x - closest.x;
                        const dy = this.y - closest.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            let repulsionStrength;
                            
                            // ENHANCED WALL ENDPOINT DETECTION
                            const endpointThreshold = 15; // Distance to consider "near endpoint"
                            const distToStart = Math.sqrt((closest.x - wall.x1) * (closest.x - wall.x1) + (closest.y - wall.y1) * (closest.y - wall.y1));
                            const distToEnd = Math.sqrt((closest.x - wall.x2) * (closest.x - wall.x2) + (closest.y - wall.y2) * (closest.y - wall.y2));
                            const isNearEndpoint = distToStart < endpointThreshold || distToEnd < endpointThreshold;
                            
                            // PARALLEL MOVEMENT DETECTION
                            const wallVectorX = wall.x2 - wall.x1;
                            const wallVectorY = wall.y2 - wall.y1;
                            const wallLength = Math.sqrt(wallVectorX * wallVectorX + wallVectorY * wallVectorY);
                            const wallUnitX = wallVectorX / wallLength;
                            const wallUnitY = wallVectorY / wallLength;
                            
                            // Check if agent is moving parallel to wall (not into it)
                            const velocityDotWall = Math.abs(this.vx * wallUnitX + this.vy * wallUnitY);
                            const velocityMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                            const isMovingParallel = velocityMagnitude > 0.1 && velocityDotWall / velocityMagnitude > 0.7;
                            
                            if (distance <= minRepulsionDistance) {
                                // EXPONENTIAL SCALING for very close distances
                                const normalizedDistance = Math.max(0.1, distance / minRepulsionDistance);
                                repulsionStrength = wallRepulsionStrength * Math.pow(1 / normalizedDistance, 1.5); // Gentler exponential
                                repulsionStrength = Math.min(repulsionStrength, wallRepulsionStrength * 8); // Lower force cap
                            } else {
                                // LINEAR SCALING for normal distances
                                repulsionStrength = wallRepulsionStrength * (maxRepulsionDistance - distance) / maxRepulsionDistance;
                            }
                            
                            // APPLY ENDPOINT AND PARALLEL MOVEMENT REDUCTIONS
                            if (isNearEndpoint) {
                                repulsionStrength *= 0.3; // Reduce to 30% near endpoints
                            }
                            
                            if (isMovingParallel) {
                                repulsionStrength *= 0.4; // Reduce to 40% when moving parallel
                            }
                            
                            // ANTI-STICKING MECHANISM
                            const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                            if (currentSpeed < 0.15 && distance < 20) { // Agent is stuck near wall
                                // Add small random nudge to break deadlock
                                const randomAngle = Math.random() * Math.PI * 2;
                                this.wallRepulsionForce.x += Math.cos(randomAngle) * 0.8;
                                this.wallRepulsionForce.y += Math.sin(randomAngle) * 0.8;
                            }
                            
                            // Apply the repulsion force
                            this.wallRepulsionForce.x += (dx / dist) * repulsionStrength;
                            this.wallRepulsionForce.y += (dy / dist) * repulsionStrength;
                        }
                    }
                }
                
                // FIRE COLLISION - Treat fires as circular walls
                for (const fire of fires) {
                    const dx = this.x - fire.x;
                    const dy = this.y - fire.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const fireRadius = fire.radius;
                    const maxRepulsionDistance = fireRadius + wallRepulsionRange;
                    const minRepulsionDistance = fireRadius + 4;
                    
                    if (distance < maxRepulsionDistance) {
                        const distanceFromEdge = distance - fireRadius;
                        
                        if (distanceFromEdge > 0 && distance > 0) {
                            let repulsionStrength;
                            
                            if (distanceFromEdge <= 4) {
                                // EXPONENTIAL SCALING for very close distances
                                const normalizedDistance = Math.max(0.1, distanceFromEdge / 4);
                                repulsionStrength = wallRepulsionStrength * Math.pow(1 / normalizedDistance, 1.5);
                                repulsionStrength = Math.min(repulsionStrength, wallRepulsionStrength * 8);
                            } else {
                                // LINEAR SCALING for normal distances
                                const maxDistance = maxRepulsionDistance - fireRadius;
                                repulsionStrength = wallRepulsionStrength * (maxDistance - distanceFromEdge) / maxDistance;
                            }
                            
                            // ANTI-STICKING MECHANISM for fire
                            const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                            if (currentSpeed < 0.15 && distanceFromEdge < 20) {
                                const randomAngle = Math.random() * Math.PI * 2;
                                this.wallRepulsionForce.x += Math.cos(randomAngle) * 0.8;
                                this.wallRepulsionForce.y += Math.sin(randomAngle) * 0.8;
                            }
                            
                            // Apply the repulsion force (away from fire center)
                            this.wallRepulsionForce.x += (dx / distance) * repulsionStrength;
                            this.wallRepulsionForce.y += (dy / distance) * repulsionStrength;
                        }
                    }
                }
            }
            
            // HARD BOUNDARY ENFORCEMENT - prevents agents from ever crossing wall lines
            enforceWallBoundaries() {
                let correctionApplied = false;
                
                for (const wall of walls) {
                    const distance = this.distanceToLineSegment(this.x, this.y, wall.x1, wall.y1, wall.x2, wall.y2);
                    
                    // If agent is too close to wall (within radius), push it away
                    if (distance < this.radius + 2) { // +2 for safety margin
                        const closest = this.closestPointOnLineSegment(this.x, this.y, wall.x1, wall.y1, wall.x2, wall.y2);
                        const dx = this.x - closest.x;
                        const dy = this.y - closest.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Calculate required distance to maintain safe separation
                            const requiredDistance = this.radius + 2;
                            const correctionDistance = requiredDistance - dist;
                            
                            if (correctionDistance > 0) {
                                // Push agent away from wall
                                const correctionX = (dx / dist) * correctionDistance;
                                const correctionY = (dy / dist) * correctionDistance;
                                
                                this.x += correctionX;
                                this.y += correctionY;
                                
                                // Also dampen velocity in the direction of the wall
                                const wallNormalX = dx / dist;
                                const wallNormalY = dy / dist;
                                const velocityDotNormal = this.vx * wallNormalX + this.vy * wallNormalY;
                                
                                if (velocityDotNormal < 0) { // Moving towards wall
                                    this.vx -= velocityDotNormal * wallNormalX * 1.5; // Remove velocity component towards wall
                                    this.vy -= velocityDotNormal * wallNormalY * 1.5;
                                }
                                
                                correctionApplied = true;
                                wallCorrectionsPerFrame++;
                            }
                        }
                    }
                }
                
                return correctionApplied;
            }
            
            applyMovement(deltaTime) {
                // Maintain minimum speed to preserve momentum
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const minSpeed = this.maxSpeed * 0.3; // 30% of max speed
                
                if (currentSpeed > 0 && currentSpeed < minSpeed) {
                    const scale = minSpeed / currentSpeed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                // Limit speed
                if (currentSpeed > this.maxSpeed) {
                    const scale = this.maxSpeed / currentSpeed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
                
                // Apply velocity damping (reduced for smoother movement)
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Update position
                this.x += this.vx * deltaTime * 60;
                this.y += this.vy * deltaTime * 60;
            }
            
            checkIfStuck(deltaTime) {
                const distance = this.distanceTo(this.lastPosition.x, this.lastPosition.y);
                
                if (distance < 2) {
                    this.stuckTimer += deltaTime * 1000;
                } else {
                    this.stuckTimer = 0;
                    this.lastPosition = { x: this.x, y: this.y };
                }
            }
            
            distanceTo(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));
                
                const xx = x1 + param * C;
                const yy = y1 + param * D;
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            closestPointOnLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return { x: x1, y: y1 };
                
                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));
                
                return {
                    x: x1 + param * C,
                    y: y1 + param * D
                };
            }
            
            draw(ctx) {
                // If agent is dead, draw red skull/cross
                if (this.isDead) {
                    ctx.save();
                    
                    // Draw red glowing skull background
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw skull symbol (X)
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 8;
                    
                    // Draw X (cross)
                    const crossSize = this.radius * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(this.x - crossSize, this.y - crossSize);
                    ctx.lineTo(this.x + crossSize, this.y + crossSize);
                    ctx.moveTo(this.x + crossSize, this.y - crossSize);
                    ctx.lineTo(this.x - crossSize, this.y + crossSize);
                    ctx.stroke();
                    
                    ctx.restore();
                    return;
                }
                
                // Draw danger warning if near fire
                if (this.dangerTimer > 0 && this.dangerTimer < this.dangerThreshold) {
                    ctx.save();
                    const dangerProgress = this.dangerTimer / this.dangerThreshold;
                    const warningIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5; // Pulsing effect
                    
                    ctx.strokeStyle = `rgba(255, 0, 0, ${dangerProgress * warningIntensity})`;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw collision circle if enabled and not escaped
                if (showCollisionCircles && !this.hasEscaped) {
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, collisionRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Personal space circle
                    ctx.strokeStyle = '#ffa726';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.personalSpace, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw vision cone for Type 2 agents if enabled (DIRECTIONAL CONE)
                if (showVisionCones && this.type === 2 && !this.hasEscaped) {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#FF9800'; // Orange for Type 2
                    
                    // Draw directional vision cone
                    const halfAngle = (visionAngle * Math.PI / 180) / 2;
                    const displayRange = visionConeDisplay; // Use display size
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.arc(this.x, this.y, displayRange, this.angle - halfAngle, this.angle + halfAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw cone outline
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#FF9800';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw vision cone for Type 0 agents if enabled (DIRECTIONAL CONE)
                if (showVisionCones && this.type === 0 && !this.hasEscaped) {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#00FFFF'; // Cyan for Type 0
                    
                    // Draw directional vision cone
                    const halfAngle = (visionAngle * Math.PI / 180) / 2;
                    const displayRange = Math.min(this.visionRange, visionConeDisplay); // Use actual vision range but cap at display size
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.arc(this.x, this.y, displayRange, this.angle - halfAngle, this.angle + halfAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw cone outline
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw vision cone for Type 1 agents if enabled (DIRECTIONAL CONE)
                if (showVisionCones && this.type === 1 && !this.hasEscaped) {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#B968C7'; // Brighter purple for Type 1
                    
                    // Draw directional vision cone
                    const halfAngle = (visionAngle * Math.PI / 180) / 2;
                    const displayRange = visionConeDisplay; // Use display size
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.arc(this.x, this.y, displayRange, this.angle - halfAngle, this.angle + halfAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw cone outline
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#B968C7';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw vision cone for Type 4 agents if enabled (DIRECTIONAL CONE)
                if (showVisionCones && this.type === 4 && !this.hasEscaped) {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#9C27B0'; // Purple for Type 4
                    
                    // Draw directional vision cone
                    const halfAngle = (visionAngle * Math.PI / 180) / 2;
                    const displayRange = visionConeDisplay; // Use display size
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.arc(this.x, this.y, displayRange, this.angle - halfAngle, this.angle + halfAngle);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw cone outline
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#9C27B0';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw path if enabled
                if (showPaths && this.currentPath && this.currentPath.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = this.hasReachedDestination ? '#4CAF50' : 
                                     (this.type === 1 ? '#4CAF50' : '#FF9800');
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    
                    for (let i = this.currentWaypoint; i < this.currentPath.length; i++) {
                        const waypoint = this.currentPath[i];
                        ctx.lineTo(waypoint.x, waypoint.y);
                    }
                    
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw agent
                ctx.save();
                
                // Determine color based on state
                let color;
                if (this.hasEscaped) {
                    color = '#808080'; // Grey for escaped agents
                } else if (this.hasReachedDestination) {
                    color = '#4CAF50'; // Green for reached destination
                } else if (this.type === 0) {
                    color = this.isExploringAroundObstacle ? '#00FFFF' : '#00BCD4'; // Cyan for Type 0, bright cyan when exploring
                } else if (this.type === 1) {
                    color = this.canSeeDestination ? '#2196F3' : '#B968C7'; // Blue if can see destination, brighter purple for exploring
                } else if (this.type === 2) {
                    color = '#FF9800'; // Orange for Type 2
                } else if (this.type === 3) {
                    color = '#FF5722'; // Red-orange for Type 3 followers
                } else if (this.type === 4) {
                    color = '#9C27B0'; // Purple for Type 4 smart followers
                }
                
                // Draw agent with glowing neon edge
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add inner glow
                ctx.shadowBlur = 4;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Reset shadow for direction indicator
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Draw direction indicator with glow
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.shadowColor = color;
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * this.radius * 0.8,
                    this.y + Math.sin(this.angle) * this.radius * 0.8
                );
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // Calculate congestion for each grid cell
        function calculateCongestion() {
            if (!gridManager || !showCongestion) return;
            
            // Reset all congestion values
            for (let y = 0; y < gridManager.rows; y++) {
                for (let x = 0; x < gridManager.cols; x++) {
                    gridManager.grid[y][x].congestion = 0;
                }
            }
            
            // Calculate congestion based on nearby agents and their speeds
            for (let y = 0; y < gridManager.rows; y++) {
                for (let x = 0; x < gridManager.cols; x++) {
                    const cellCenterX = (x + 0.5) * gridSize;
                    const cellCenterY = (y + 0.5) * gridSize;
                    
                    let localDensity = 0;
                    let avgSpeed = 0;
                    let agentCount = 0;
                    let nearbyTileAgentCount = 0;
                    const influenceRadius = gridSize * 2; // Check within 2 grid cells
                    
                    // Count agents in nearby tiles (most deciding factor)
                    const tileRadius = 2; // Check 2 tiles in each direction
                    for (let dy = -tileRadius; dy <= tileRadius; dy++) {
                        for (let dx = -tileRadius; dx <= tileRadius; dx++) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            
                            if (checkX >= 0 && checkX < gridManager.cols && 
                                checkY >= 0 && checkY < gridManager.rows) {
                                
                                // Count agents in this tile
                                for (const agent of agents) {
                                    if (agent.isDead || agent.hasEscaped) continue;
                                    
                                    const agentTileX = Math.floor(agent.x / gridSize);
                                    const agentTileY = Math.floor(agent.y / gridSize);
                                    
                                    if (agentTileX === checkX && agentTileY === checkY) {
                                        // Weight by distance from center tile
                                        const tileDistance = Math.sqrt(dx * dx + dy * dy);
                                        const weight = Math.max(0, 1 - tileDistance / tileRadius);
                                        nearbyTileAgentCount += weight;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Count agents within influence radius
                    for (const agent of agents) {
                        if (agent.isDead || agent.hasEscaped) continue;
                        
                        const distance = Math.sqrt(
                            (agent.x - cellCenterX) ** 2 + 
                            (agent.y - cellCenterY) ** 2
                        );
                        
                        if (distance <= influenceRadius) {
                            // Weight by inverse distance (closer agents have more influence)
                            const weight = Math.max(0, 1 - distance / influenceRadius);
                            localDensity += weight;
                            
                            // Calculate agent speed
                            const speed = Math.sqrt(agent.vx ** 2 + agent.vy ** 2);
                            avgSpeed += speed * weight;
                            agentCount += weight;
                        }
                    }
                    
                    if (agentCount > 0 || nearbyTileAgentCount > 0) {
                        if (agentCount > 0) {
                            avgSpeed /= agentCount;
                        }
                        
                        // Nearby tile agent count is the most deciding factor
                        // Normalize nearby tile agent count (assume max 8 agents in nearby tiles)
                        const normalizedTileCount = Math.min(nearbyTileAgentCount / 8, 1);
                        
                        // Normalize speed (assume max speed of 100 pixels/second)
                        const normalizedSpeed = Math.min(avgSpeed / 100, 1);
                        
                        // Congestion primarily based on nearby tile agent count, with speed as secondary factor
                        // Formula: nearby_agents_factor * 0.8 + speed_factor * 0.2
                        const speedFactor = agentCount > 0 ? (1 - normalizedSpeed * 0.7) : 1;
                        gridManager.grid[y][x].congestion = normalizedTileCount * 0.8 + speedFactor * 0.2;
                    }
                }
            }
        }
        
        // Animation loop
        function animate(currentTime) {
            if (!isRunning) return;
            
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.016); // Cap at 60 FPS
            lastTime = currentTime;
            simulationTime += deltaTime;
            
            // Reset performance counters
            collisionChecksPerFrame = 0;
            wallCorrectionsPerFrame = 0;
            
            // Update agents
            for (const agent of agents) {
                agent.update(deltaTime);
            }
            
            // Calculate congestion for visualization
            calculateCongestion();
            
            // Update FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Render
            render();
            updateUI();
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Render function
        function render() {
            // Clear canvas with dark background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid if enabled
            if (showGrid && gridManager) {
                ctx.save();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                
                // Draw vertical lines
                for (let x = 0; x <= canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Draw horizontal lines
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw blocked cells
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                for (let y = 0; y < gridManager.rows; y++) {
                    for (let x = 0; x < gridManager.cols; x++) {
                        if (gridManager.grid[y][x].blocked) {
                            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        }
                    }
                }
                
                ctx.restore();
            }
            
            // Draw congestion visualization if enabled
            if (showCongestion && gridManager) {
                ctx.save();
                for (let y = 0; y < gridManager.rows; y++) {
                    for (let x = 0; x < gridManager.cols; x++) {
                        const congestion = gridManager.grid[y][x].congestion;
                        if (congestion > 0.01) { // Only draw if there's meaningful congestion
                            // Color from green (low) → yellow (medium) → red (high congestion)
                            const intensity = Math.min(congestion * 3, 1); // Amplify congestion for better visibility
                            
                            let red, green, blue;
                            if (intensity <= 0.5) {
                                // Green to Yellow (0.0 to 0.5)
                                red = Math.floor(255 * intensity * 2); // 0 to 255
                                green = 255; // Stay at 255
                                blue = 0;
                            } else {
                                // Yellow to Red (0.5 to 1.0)
                                red = 255; // Stay at 255
                                green = Math.floor(255 * (1 - (intensity - 0.5) * 2)); // 255 to 0
                                blue = 0;
                            }
                            const alpha = 0.4 + (intensity * 0.4); // Vary transparency with congestion level
                            
                            ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
                            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        }
                    }
                }
                ctx.restore();
            }
            
            // Draw walls
            for (const wall of walls) {
                wall.draw(ctx);
            }
            
            // Draw doors
            for (const door of doors) {
                door.draw(ctx);
            }
            
            // Draw fires
            for (const fire of fires) {
                fire.draw(ctx);
            }
            
            // Draw destination
            if (destination) {
                destination.draw(ctx);
            }
            
            // Draw agents
            for (const agent of agents) {
                agent.draw(ctx);
            }
            
            // Draw preview wall if drawing
            if (previewWall) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(previewWall.x1, previewWall.y1);
                ctx.lineTo(previewWall.x2, previewWall.y2);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw preview rectangle if drawing
            if (previewRectangle) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                
                const x = Math.min(previewRectangle.x1, previewRectangle.x2);
                const y = Math.min(previewRectangle.y1, previewRectangle.y2);
                const width = Math.abs(previewRectangle.x2 - previewRectangle.x1);
                const height = Math.abs(previewRectangle.y2 - previewRectangle.y1);
                
                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
                ctx.restore();
            }
            
            // Draw eraser preview if in eraser mode and mouse is in canvas
            if (currentMode === 'eraser' && mouseInCanvas) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, eraserRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw door preview if in door mode and mouse is in canvas
            if (currentMode === 'door' && mouseInCanvas) {
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; // Teal color
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, eraserRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Erase parts of walls within eraser radius
        function eraseWallParts(x, y) {
            const newWalls = [];
            let wallsModified = false;
            
            // Also erase doors within eraser radius
            for (let i = doors.length - 1; i >= 0; i--) {
                const door = doors[i];
                const doorCenterX = (door.x1 + door.x2) / 2;
                const doorCenterY = (door.y1 + door.y2) / 2;
                const distanceToDoor = Math.sqrt((x - doorCenterX) ** 2 + (y - doorCenterY) ** 2);
                
                if (distanceToDoor <= eraserRadius) {
                    doors.splice(i, 1);
                }
            }
            
            for (const wall of walls) {
                const distance = distanceToLineSegment(x, y, wall.x1, wall.y1, wall.x2, wall.y2);
                
                if (distance <= eraserRadius) {
                    // Wall intersects with eraser, create a gap
                    wallsModified = true;
                    
                    // Find the closest point on the wall to the eraser center
                    const wallLength = Math.sqrt((wall.x2 - wall.x1) ** 2 + (wall.y2 - wall.y1) ** 2);
                    const wallDirX = (wall.x2 - wall.x1) / wallLength;
                    const wallDirY = (wall.y2 - wall.y1) / wallLength;
                    
                    // Project eraser center onto the wall line
                    const toEraserX = x - wall.x1;
                    const toEraserY = y - wall.y1;
                    const projectionLength = toEraserX * wallDirX + toEraserY * wallDirY;
                    
                    // Clamp projection to wall bounds
                    const clampedProjection = Math.max(0, Math.min(wallLength, projectionLength));
                    
                    // Create gap around the projection point
                    const gapSize = eraserRadius * 1.5;
                    const gapStart = clampedProjection - gapSize / 2;
                    const gapEnd = clampedProjection + gapSize / 2;
                    
                    // Create first wall segment (from start to gap start) if there's room
                    if (gapStart > 10) {
                        const segEndX = wall.x1 + gapStart * wallDirX;
                        const segEndY = wall.y1 + gapStart * wallDirY;
                        newWalls.push(new Wall(wall.x1, wall.y1, segEndX, segEndY));
                    }
                    
                    // Create second wall segment (from gap end to wall end) if there's room
                    if (gapEnd < wallLength - 10) {
                        const segStartX = wall.x1 + gapEnd * wallDirX;
                        const segStartY = wall.y1 + gapEnd * wallDirY;
                        newWalls.push(new Wall(segStartX, segStartY, wall.x2, wall.y2));
                    }
                } else {
                    // Wall doesn't intersect with eraser, keep it unchanged
                    newWalls.push(wall);
                }
            }
            
            if (wallsModified) {
                walls.length = 0;
                walls.push(...newWalls);
                updatePathfinding();
                updateUI();
            }
        }
        
        // Create door parts - same logic as eraser but also creates visual door indicators
        function createDoorParts(x, y) {
            const newWalls = [];
            let wallsModified = false;
            
            for (const wall of walls) {
                const distance = distanceToLineSegment(x, y, wall.x1, wall.y1, wall.x2, wall.y2);
                
                if (distance <= eraserRadius) {
                    // Wall intersects with door tool, create a gap (same as eraser)
                    wallsModified = true;
                    
                    // Find the closest point on the wall to the door center
                    const wallLength = Math.sqrt((wall.x2 - wall.x1) ** 2 + (wall.y2 - wall.y1) ** 2);
                    const wallDirX = (wall.x2 - wall.x1) / wallLength;
                    const wallDirY = (wall.y2 - wall.y1) / wallLength;
                    
                    // Project door center onto the wall line
                    const toDoorX = x - wall.x1;
                    const toDoorY = y - wall.y1;
                    const projectionLength = toDoorX * wallDirX + toDoorY * wallDirY;
                    
                    // Clamp projection to wall bounds
                    const clampedProjection = Math.max(0, Math.min(wallLength, projectionLength));
                    
                    // Create gap around the projection point (larger size for better visibility)
                    const gapSize = eraserRadius * 2.0; // Increased from 1.5 to 2.0
                    const gapStart = clampedProjection - gapSize / 2;
                    const gapEnd = clampedProjection + gapSize / 2;
                    
                    // Create first wall segment (from start to gap start) if there's room
                    if (gapStart > 10) {
                        const segEndX = wall.x1 + gapStart * wallDirX;
                        const segEndY = wall.y1 + gapStart * wallDirY;
                        newWalls.push(new Wall(wall.x1, wall.y1, segEndX, segEndY));
                    }
                    
                    // Create visual door indicator in the gap
                    if (gapEnd > gapStart && gapStart < wallLength && gapEnd > 0) {
                        const doorStartX = wall.x1 + Math.max(0, gapStart) * wallDirX;
                        const doorStartY = wall.y1 + Math.max(0, gapStart) * wallDirY;
                        const doorEndX = wall.x1 + Math.min(wallLength, gapEnd) * wallDirX;
                        const doorEndY = wall.y1 + Math.min(wallLength, gapEnd) * wallDirY;
                        doors.push(new Door(doorStartX, doorStartY, doorEndX, doorEndY));
                    }
                    
                    // Create second wall segment (from gap end to wall end) if there's room
                    if (gapEnd < wallLength - 10) {
                        const segStartX = wall.x1 + gapEnd * wallDirX;
                        const segStartY = wall.y1 + gapEnd * wallDirY;
                        newWalls.push(new Wall(segStartX, segStartY, wall.x2, wall.y2));
                    }
                } else {
                    // Wall doesn't intersect with door tool, keep it unchanged
                    newWalls.push(wall);
                }
            }
            
            if (wallsModified) {
                walls.length = 0;
                walls.push(...newWalls);
                updatePathfinding();
                updateUI();
                render();
            }
        }
        
        // Utility function to find closest point on line segment
        function closestPointOnLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return { x: x1, y: y1 };
            
            let param = dot / lenSq;
            param = Math.max(0, Math.min(1, param));
            
            return {
                x: x1 + param * C,
                y: y1 + param * D
            };
        }
        
        // Update UI
        function updateUI() {
            const type0Count = agents.filter(a => a.type === 0 && !a.isDead && !a.hasEscaped).length;
            const type1Count = agents.filter(a => a.type === 1 && !a.isDead && !a.hasEscaped).length;
            const type2Count = agents.filter(a => a.type === 2 && !a.isDead && !a.hasEscaped).length;
            const type3Count = agents.filter(a => a.type === 3 && !a.isDead && !a.hasEscaped).length;
            const type4Count = agents.filter(a => a.type === 4 && !a.isDead && !a.hasEscaped).length;
            const deadCount = agents.filter(a => a.isDead).length;
            const escapedCount = agents.filter(a => a.hasEscaped).length;
            const aliveCount = agents.length - deadCount - escapedCount;
            const type2Exploring = agents.filter(a => a.type === 2 && a.isExploring && !a.isDead && !a.hasEscaped).length;
            const type2CanSeeDestination = agents.filter(a => a.type === 2 && a.canSeeDestination && !a.isDead).length;
            
            // Calculate average speed only for living agents
            const livingAgents = agents.filter(a => !a.isDead);
            const totalSpeed = livingAgents.reduce((sum, agent) => sum + Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy), 0);
            const avgSpeed = livingAgents.length > 0 ? totalSpeed / livingAgents.length : 0;
            
            // Calculate average escape time (excluding Type 1: Random Explorers)
            const escapedAgentsWithTime = agents.filter(a => a.hasEscaped && a.escapeTimeDuration !== undefined && a.type !== 1);
            const totalEscapeTime = escapedAgentsWithTime.reduce((sum, agent) => sum + agent.escapeTimeDuration, 0);
            const avgEscapeTime = escapedAgentsWithTime.length > 0 ? totalEscapeTime / escapedAgentsWithTime.length : 0;
            
            // Count only visible walls (exclude invisible fire walls)
            const visibleWallCount = walls.filter(wall => !wall.isInvisible).length;
            const totalObstacleCount = visibleWallCount + fires.length;
            
            document.getElementById('agentInfo').textContent = 
                `Agents: ${aliveCount} alive, ${deadCount} dead, ${escapedCount} escaped | Obstacles: ${totalObstacleCount} | ${destination ? 'Destination set' : 'No destination set'}`;
            document.getElementById('performanceInfo').textContent = 
                `FPS: ${fps} | Time: ${simulationTime.toFixed(1)}s | Pathfinding: ${lastPathfindingTime.toFixed(1)}ms`;
            
            document.getElementById('totalAgents').textContent = `${aliveCount}/${agents.length}`;
            document.getElementById('type0Agents').textContent = type0Count;
            document.getElementById('type1Agents').textContent = type1Count;
            document.getElementById('type2Agents').textContent = type2Count;
            document.getElementById('type3Agents').textContent = type3Count;
            document.getElementById('type4Agents').textContent = type4Count;
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2) + ' m/s';
            
            document.getElementById('wallCount').textContent = visibleWallCount;
            document.getElementById('fireCount').textContent = fires.length;
            document.getElementById('destinationStatus').textContent = destination ? `(${Math.round(destination.x)}, ${Math.round(destination.y)})` : 'None';
            document.getElementById('deadCount').textContent = deadCount;
            document.getElementById('escapedCount').textContent = escapedCount;
            document.getElementById('avgEscTime').textContent = avgEscapeTime.toFixed(1) + 's';
            document.getElementById('agentsCount').textContent = agents.length;
            
            document.getElementById('simulationStatus').textContent = isRunning ? 'Running' : 'Stopped';
            
            // Update debug info
            const cacheSize = pathManager ? pathManager.getCacheSize() : 0;
            const gridInfo = gridManager ? `${gridManager.cols}x${gridManager.rows}` : 'Not initialized';
            document.getElementById('debugInfo').textContent = 
                `Grid: ${gridInfo} | Pathfinding Cache: ${cacheSize} paths | Collision Checks: ${collisionChecksPerFrame}/frame | Type 2 Exploring: ${type2Exploring} | Type 2 Can See Destination: ${type2CanSeeDestination} | Wall Corrections: ${wallCorrectionsPerFrame}/frame | Dead: ${deadCount}`;
        }
        
        // Utility function to calculate distance from point to line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return Math.sqrt(A * A + B * B);
            
            let param = dot / lenSq;
            param = Math.max(0, Math.min(1, param));
            
            const xx = x1 + param * C;
            const yy = y1 + param * D;
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Event handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isRunning) {
                if (!gridManager) {
                    initializePathfinding();
                }
                isRunning = true;
                lastTime = performance.now();
                animationId = requestAnimationFrame(animate);
                updateUI();
            }
        });
        
        document.getElementById('stopBtn').addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            updateUI();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            agents = [];
            walls = [];
            doors = [];
            // Remove invisible walls for all fires before clearing
            for (const fire of fires) {
                fire.removeInvisibleWalls();
            }
            fires = [];
            destination = null;
            simulationTime = 0;
            frameCount = 0;
            fps = 0;
            if (pathManager) {
                pathManager.invalidateCache();
            }
            updatePathfinding();
            render();
            updateUI();
        });
        
        // Agent type selection
        document.querySelectorAll('.agent-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.agent-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedAgentType = parseInt(btn.dataset.type);
                
                // Auto-switch to Add Agents mode
                currentMode = 'addAgent';
                document.getElementById('modeIndicator').textContent = 'Click on the canvas to add agents';
            });
        });
        
        // Mode buttons
        document.getElementById('addAgentBtn').addEventListener('click', () => {
            currentMode = 'addAgent';
            document.getElementById('modeIndicator').textContent = 'Click on the canvas to add agents';
        });
        
        document.getElementById('setDestinationBtn').addEventListener('click', () => {
            currentMode = 'setDestination';
            document.getElementById('modeIndicator').textContent = 'Click to set the exit destination';
        });
        
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'drawWall';
            document.getElementById('modeIndicator').textContent = 'Click and drag to draw walls';
        });
        
        document.getElementById('drawBlockBtn').addEventListener('click', () => {
            currentMode = 'drawBlock';
            document.getElementById('modeIndicator').textContent = 'Click and drag to draw rectangular blocks';
        });
        
        document.getElementById('placeFireBtn').addEventListener('click', () => {
            currentMode = 'placeFire';
            document.getElementById('modeIndicator').textContent = 'Click to place fire elements';
        });
        
        document.getElementById('eraserBtn').addEventListener('click', () => {
            currentMode = 'eraser';
            document.getElementById('modeIndicator').textContent = 'Click and drag to erase parts of walls';
        });
        
        document.getElementById('doorBtn').addEventListener('click', () => {
            currentMode = 'door';
            document.getElementById('modeIndicator').textContent = 'Click and drag to create teal doors in walls';
        });
        
        document.getElementById('deleteBtn').addEventListener('click', () => {
            currentMode = 'delete';
            document.getElementById('modeIndicator').textContent = 'Click on walls or fires to delete them';
        });
        
        // Agents popup functionality
        document.getElementById('agentsBlock').addEventListener('click', () => {
            showAgentsPopup();
        });
        
        function showAgentsPopup() {
            if (agents.length === 0) {
                return; // No agents to show
            }
            
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'agents-popup';
            
            // Add title
            const title = document.createElement('h3');
            title.textContent = 'Agent Details';
            popup.appendChild(title);
            
            // Create table
            const table = document.createElement('table');
            table.className = 'agents-table';
            
            // Add table header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            ['Symbol', 'Type', 'Speed', 'Location', 'Activity', 'Escape Time'].forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Add table body
            const tbody = document.createElement('tbody');
            table.appendChild(tbody);
            popup.appendChild(table);
            
            // Function to update table content
            const updateTable = () => {
                // Clear existing rows
                tbody.innerHTML = '';
                
                // Add current agent data
                agents.forEach(agent => {
                const row = document.createElement('tr');
                
                    // Symbol column (mini-camera view)
                    const symbolCell = document.createElement('td');
                    const camera = document.createElement('div');
                    camera.className = 'agent-camera';
                    
                    // Create 6x6 grid
                    const grid = document.createElement('div');
                    grid.className = 'camera-grid';
                    
                    // Get agent's grid position
                    const agentGridX = Math.floor(agent.x / gridManager.cellSize);
                    const agentGridY = Math.floor(agent.y / gridManager.cellSize);
                    
                    // Create 6x6 view around agent
                    for (let dy = -3; dy < 3; dy++) {
                        for (let dx = -3; dx < 3; dx++) {
                            const cell = document.createElement('div');
                            cell.className = 'camera-cell';
                            
                            const checkX = agentGridX + dx;
                            const checkY = agentGridY + dy;
                            
                            // Check what's at this position
                            if (dx === 0 && dy === 0) {
                                // Agent position
                                cell.className += ' camera-agent';
                                cell.style.backgroundColor = getAgentColor(agent.type);
                            } else if (checkX >= 0 && checkX < gridManager.width && 
                                     checkY >= 0 && checkY < gridManager.height) {
                                // Check for walls
                                if (gridManager.grid[checkY] && gridManager.grid[checkY][checkX] && 
                                    gridManager.grid[checkY][checkX].blocked) {
                                    cell.style.backgroundColor = '#ffffff';
                                }
                                // Check for fires
                                const fireAtPos = fires.find(f => 
                                    Math.floor(f.x / gridManager.cellSize) === checkX && 
                                    Math.floor(f.y / gridManager.cellSize) === checkY);
                                if (fireAtPos) {
                                    cell.style.backgroundColor = '#ff4444';
                                }
                                // Check for other agents
                                const otherAgent = agents.find(a => a !== agent && 
                                    Math.floor(a.x / gridManager.cellSize) === checkX && 
                                    Math.floor(a.y / gridManager.cellSize) === checkY);
                                if (otherAgent) {
                                    cell.style.backgroundColor = getAgentColor(otherAgent.type);
                                    cell.style.opacity = '0.7';
                                }
                            }
                            
                            grid.appendChild(cell);
                        }
                    }
                    
                    camera.appendChild(grid);
                    symbolCell.appendChild(camera);
                    row.appendChild(symbolCell);
                
                // Type column
                const typeCell = document.createElement('td');
                typeCell.textContent = `Type ${agent.type}`;
                row.appendChild(typeCell);
                
                // Speed column
                const speedCell = document.createElement('td');
                const currentSpeed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
                speedCell.textContent = currentSpeed.toFixed(2) + ' m/s';
                row.appendChild(speedCell);
                
                // Location column
                const locationCell = document.createElement('td');
                locationCell.textContent = `(${Math.round(agent.x)}, ${Math.round(agent.y)})`;
                row.appendChild(locationCell);
                
                // Activity column
                const activityCell = document.createElement('td');
                let activity = 'Idle';
                
                if (agent.isDead) {
                    activity = 'Dead';
                } else if (agent.hasEscaped) {
                    activity = 'Escaped';
                } else {
                    // Check if agent is following another agent (Types 3 and 4)
                    if ((agent.type === 3 || agent.type === 4) && agent.followTarget) {
                        activity = 'Following';
                    }
                    // Check if agent is near fires
                    else if (fires.some(fire => {
                        const dist = Math.sqrt((agent.x - fire.x) ** 2 + (agent.y - fire.y) ** 2);
                        return dist < 60; // Within fire avoidance range
                    })) {
                        activity = 'Avoiding danger';
                    }
                    // Check if agent has a path to destination
                    else if (agent.path && agent.path.length > 0) {
                        // Check if destination is the exit
                        if (destination && agent.path[agent.path.length - 1]) {
                            const lastPoint = agent.path[agent.path.length - 1];
                            const distToDest = Math.sqrt((lastPoint.x - destination.x) ** 2 + (lastPoint.y - destination.y) ** 2);
                            if (distToDest < 50) {
                                activity = 'Going to exit';
                            } else {
                                activity = 'Navigating past wall';
                            }
                        } else {
                            activity = 'Navigating past wall';
                        }
                    }
                    // Check if agent is moving but has no clear path
                    else if (currentSpeed > 0.1) {
                        activity = 'Looking for exit';
                    }
                    // Check if agent is stuck or stationary
                    else if (currentSpeed < 0.1) {
                        activity = 'Looking for exit';
                    }
                }
                
                activityCell.textContent = activity;
                row.appendChild(activityCell);
                
                // Escape time column
                const escapeTimeCell = document.createElement('td');
                if (agent.hasEscaped && agent.escapeTimeDuration !== undefined) {
                    escapeTimeCell.textContent = agent.escapeTimeDuration.toFixed(1) + 's';
                } else {
                    escapeTimeCell.textContent = '-';
                }
                row.appendChild(escapeTimeCell);
                
                tbody.appendChild(row);
            });
        };
            
            // Initial table population
            updateTable();
            
            // Set up real-time updates (update every 100ms for smooth real-time feel)
            const updateInterval = setInterval(updateTable, 100);
            
            // Add to document
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Close popup when clicking overlay or pressing escape
            const closePopup = () => {
                clearInterval(updateInterval); // Stop real-time updates
                document.body.removeChild(overlay);
                document.body.removeChild(popup);
            };
            
            overlay.addEventListener('click', closePopup);
            document.addEventListener('keydown', function escapeHandler(e) {
                if (e.key === 'Escape') {
                    closePopup();
                    document.removeEventListener('keydown', escapeHandler);
                }
            });
        }
        
        function getAgentColor(type) {
            switch (type) {
                case 0: return '#00ffff'; // Cyan
                case 1: return '#9966ff'; // Purple
                case 2: return '#ff9900'; // Orange
                case 3: return '#ff6600'; // Red-orange
                case 4: return '#cc66ff'; // Light purple
                default: return '#ffffff';
            }
        }
        
        // Canvas interactions
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentMode === 'addAgent') {
                agents.push(new Agent(x, y, selectedAgentType));
                render();
                updateUI();
            } else if (currentMode === 'setDestination') {
                destination = new Destination(x, y);
                // Clear all agent paths to force replanning
                for (const agent of agents) {
                    agent.currentPath = null;
                    agent.currentWaypoint = 0;
                    agent.hasReachedDestination = false;
                    agent.lastPathRequest = 0;
                    if (agent.type === 2) {
                        agent.isExploring = true;
                        agent.canSeeDestination = false;
                    }
                }
                render();
                updateUI();
            } else if (currentMode === 'placeFire') {
                fires.push(new Fire(x, y));
                updatePathfinding(); // Update pathfinding to account for new fire obstacle
                render();
                updateUI();
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentMode === 'drawWall') {
                wallStartX = x;
                wallStartY = y;
                isDrawingWall = true;
            } else if (currentMode === 'drawBlock') {
                rectangleStartX = x;
                rectangleStartY = y;
                isDrawingRectangle = true;
            } else if (currentMode === 'eraser') {
                // Start erasing and erase at current position
                isErasing = true;
                lastEraseX = x;
                lastEraseY = y;
                eraseWallParts(x, y);
            } else if (currentMode === 'door') {
                // Start creating door and create at current position
                isCreatingDoor = true;
                lastDoorX = x;
                lastDoorY = y;
                createDoorParts(x, y);
            } else if (currentMode === 'delete') {
                // Check for walls to delete
                for (let i = walls.length - 1; i >= 0; i--) {
                    const wall = walls[i];
                    const distance = distanceToLineSegment(x, y, wall.x1, wall.y1, wall.x2, wall.y2);
                    if (distance < 10) { // 10 pixel tolerance
                        walls.splice(i, 1);
                        updatePathfinding();
                        render();
                        updateUI();
                        return;
                    }
                }
                
                // Check for fires to delete - find the closest fire center
                let closestFireIndex = -1;
                let closestDistance = Infinity;
                
                for (let i = 0; i < fires.length; i++) {
                    const fire = fires[i];
                    const distance = Math.sqrt((x - fire.x) ** 2 + (y - fire.y) ** 2);
                    if (distance < fire.radius && distance < closestDistance) {
                        closestDistance = distance;
                        closestFireIndex = i;
                    }
                }
                
                if (closestFireIndex !== -1) {
                    fires[closestFireIndex].removeInvisibleWalls();
                    fires.splice(closestFireIndex, 1);
                    updatePathfinding();
                    render();
                    updateUI();
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            // Check if mouse is within canvas bounds
            mouseInCanvas = mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height;
            
            if (currentMode === 'drawWall' && isDrawingWall) {
                previewWall = {
                    x1: wallStartX,
                    y1: wallStartY,
                    x2: mouseX,
                    y2: mouseY
                };
                render();
            } else if (currentMode === 'drawBlock' && isDrawingRectangle) {
                previewRectangle = {
                    x1: rectangleStartX,
                    y1: rectangleStartY,
                    x2: mouseX,
                    y2: mouseY
                };
                render();
            } else if (currentMode === 'eraser') {
                // Always render to show eraser preview, and erase if dragging and moved significantly
                if (isErasing) {
                    const distanceMoved = Math.sqrt((mouseX - lastEraseX) ** 2 + (mouseY - lastEraseY) ** 2);
                    if (distanceMoved > eraserRadius * 0.3) { // Only erase if moved 30% of eraser radius
                        lastEraseX = mouseX;
                        lastEraseY = mouseY;
                        eraseWallParts(mouseX, mouseY);
                    }
                }
                render();
            } else if (currentMode === 'door') {
                // Always render to show door preview, and create doors if dragging and moved significantly
                if (isCreatingDoor) {
                    const distanceMoved = Math.sqrt((mouseX - lastDoorX) ** 2 + (mouseY - lastDoorY) ** 2);
                    if (distanceMoved > eraserRadius * 0.3) { // Only create door if moved 30% of radius
                        lastDoorX = mouseX;
                        lastDoorY = mouseY;
                        createDoorParts(mouseX, mouseY);
                    }
                }
                render();
            } else {
                previewWall = null;
                previewRectangle = null;
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (currentMode === 'drawWall' && isDrawingWall) {
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                walls.push(new Wall(wallStartX, wallStartY, endX, endY));
                isDrawingWall = false;
                previewWall = null;
                
                updatePathfinding();
                render();
                updateUI();
            } else if (currentMode === 'drawBlock' && isDrawingRectangle) {
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                // Create 4 walls forming a rectangle
                const x1 = Math.min(rectangleStartX, endX);
                const y1 = Math.min(rectangleStartY, endY);
                const x2 = Math.max(rectangleStartX, endX);
                const y2 = Math.max(rectangleStartY, endY);
                
                // Only create rectangle if it has meaningful size
                if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {
                    walls.push(new Wall(x1, y1, x2, y1)); // Top
                    walls.push(new Wall(x2, y1, x2, y2)); // Right
                    walls.push(new Wall(x2, y2, x1, y2)); // Bottom
                    walls.push(new Wall(x1, y2, x1, y1)); // Left
                }
                
                isDrawingRectangle = false;
                previewRectangle = null;
                
                updatePathfinding();
                render();
                updateUI();
            }
            
            // Stop erasing on mouse up
            if (isErasing) {
                isErasing = false;
            }
            
            // Stop creating doors on mouse up
            if (isCreatingDoor) {
                isCreatingDoor = false;
            }
        });
        
        // Canvas mouse enter/leave events
        canvas.addEventListener('mouseenter', () => {
            mouseInCanvas = true;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseInCanvas = false;
            render(); // Re-render to hide eraser preview
        });
        
        // Management buttons
        document.getElementById('addRandomBtn').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * (canvas.width - 40) + 20;
                const y = Math.random() * (canvas.height - 40) + 20;
                const rand = Math.random();
                let type;
                if (rand < 0.25) {
                    type = 0; // 25% Type 0 (Smart Agents)
                } else if (rand < 0.55) {
                    type = 1; // 30% Type 1
                } else if (rand < 0.8) {
                    type = 2; // 25% Type 2
                } else {
                    type = 3; // 20% Type 3
                }
                agents.push(new Agent(x, y, type));
            }
            render();
            updateUI();
        });
        
        document.getElementById('clearAgentsBtn').addEventListener('click', () => {
            agents = [];
            render();
            updateUI();
        });
        
        document.getElementById('clearWallsBtn').addEventListener('click', () => {
            walls = [];
            doors = [];
            updatePathfinding();
            render();
            updateUI();
        });
        
        document.getElementById('clearFiresBtn').addEventListener('click', () => {
            // Remove invisible walls for all fires
            for (const fire of fires) {
                fire.removeInvisibleWalls();
            }
            fires = [];
            updatePathfinding(); // Update pathfinding to remove fire obstacles
            render();
            updateUI();
        });
        
        document.getElementById('clearDestinationBtn').addEventListener('click', () => {
            destination = null;
            render();
            updateUI();
        });
        
        // Scenario buttons
        document.getElementById('corridorBtn').addEventListener('click', () => {
            agents = [];
            walls = [];
            doors = [];
            destination = null;
            
            // Create corridor
            walls.push(new Wall(100, 150, 600, 150));
            walls.push(new Wall(100, 250, 600, 250));
            walls.push(new Wall(100, 150, 100, 250));
            
            // Add agents (mix of types)
            for (let i = 0; i < 20; i++) {
                const x = 120 + Math.random() * 200;
                const y = 170 + Math.random() * 60;
                const type = Math.random() < 0.6 ? 1 : 2;
                agents.push(new Agent(x, y, type));
            }
            
            // Set destination
            destination = new Destination(650, 200);
            
            updatePathfinding();
            render();
            updateUI();
        });
        
        document.getElementById('roomBtn').addEventListener('click', () => {
            agents = [];
            walls = [];
            doors = [];
            destination = null;
            
            // Create room
            walls.push(new Wall(200, 200, 600, 200));
            walls.push(new Wall(600, 200, 600, 400));
            walls.push(new Wall(600, 400, 200, 400));
            walls.push(new Wall(200, 400, 200, 300));
            walls.push(new Wall(200, 250, 200, 200));
            
            // Add agents (mix of types)
            for (let i = 0; i < 30; i++) {
                const x = 220 + Math.random() * 360;
                const y = 220 + Math.random() * 160;
                const type = Math.random() < 0.5 ? 1 : 2;
                agents.push(new Agent(x, y, type));
            }
            
            // Set destination
            destination = new Destination(200, 275);
            
            updatePathfinding();
            render();
            updateUI();
        });
        
        document.getElementById('bottleneckBtn').addEventListener('click', () => {
            agents = [];
            walls = [];
            doors = [];
            destination = null;
            
            // Create bottleneck
            walls.push(new Wall(300, 100, 300, 180));
            walls.push(new Wall(300, 220, 300, 300));
            
            // Add agents (mix of types)
            for (let i = 0; i < 25; i++) {
                const x = 100 + Math.random() * 150;
                const y = 120 + Math.random() * 160;
                const type = Math.random() < 0.6 ? 1 : 2;
                agents.push(new Agent(x, y, type));
            }
            
            // Set destination
            destination = new Destination(500, 200);
            
            updatePathfinding();
            render();
            updateUI();
        });
        
        document.getElementById('mazeBtn').addEventListener('click', () => {
            agents = [];
            walls = [];
            doors = [];
            destination = null;
            
            // Create complex maze
            walls.push(new Wall(100, 100, 300, 100));
            walls.push(new Wall(400, 100, 700, 100));
            walls.push(new Wall(100, 100, 100, 200));
            walls.push(new Wall(300, 100, 300, 200));
            walls.push(new Wall(400, 100, 400, 200));
            walls.push(new Wall(700, 100, 700, 300));
            walls.push(new Wall(200, 200, 400, 200));
            walls.push(new Wall(500, 200, 700, 200));
            walls.push(new Wall(100, 300, 300, 300));
            walls.push(new Wall(400, 300, 600, 300));
            walls.push(new Wall(200, 200, 200, 300));
            walls.push(new Wall(500, 200, 500, 300));
            
            // Add agents (mix of types)
            for (let i = 0; i < 15; i++) {
                const x = 120 + Math.random() * 60;
                const y = 120 + Math.random() * 60;
                const type = Math.random() < 0.4 ? 1 : 2;
                agents.push(new Agent(x, y, type));
            }
            
            // Set destination
            destination = new Destination(650, 250);
            
            updatePathfinding();
            render();
            updateUI();
        });
        
        document.getElementById('classroomBtn').addEventListener('click', () => {
            agents = [];
            walls = [];
            doors = [];
            // Remove invisible walls for all fires before clearing
            for (const fire of fires) {
                fire.removeInvisibleWalls();
            }
            fires = [];
            destination = null;
            
            // Create classroom walls (rectangular room with exit at top-left)
            const roomLeft = 150;
            const roomRight = 650;
            const roomTop = 100;
            const roomBottom = 350;
            const exitWidth = 50; // Width of exit
            
            // Top wall with exit at left corner
            walls.push(new Wall(roomLeft + exitWidth, roomTop, roomRight, roomTop)); // Top wall (right of exit)
            
            // Bottom wall (complete)
            walls.push(new Wall(roomLeft, roomBottom, roomRight, roomBottom)); // Bottom wall
            
            // Left wall with gap for exit
            walls.push(new Wall(roomLeft, roomTop + exitWidth, roomLeft, roomBottom)); // Left wall (below exit)
            
            // Right wall (complete)
            walls.push(new Wall(roomRight, roomTop, roomRight, roomBottom)); // Right wall
            
            // Create 3x8 matrix of Type 3 agents (students) - properly positioned within classroom
            const startX = roomLeft + 50; // Start well inside the left wall
            const startY = roomTop + 80;  // Start well inside the top wall
            const spacingX = 60;
            const spacingY = 30;
            const maxX = roomRight - 50;  // Don't go too close to right wall
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 8; col++) {
                    const x = startX + col * spacingX;
                    const y = startY + row * spacingY;
                    // Only place agent if it's within the classroom bounds
                    if (x < maxX && y < roomBottom - 50) {
                        agents.push(new Agent(x, y, 3)); // Type 3 (Followers)
                    }
                }
            }
            
            // Add one Type 2 agent (teacher) above the students, centered
            const teacherX = startX + 3.5 * spacingX; // Center of the student formation
            const teacherY = startY - 40; // Above the students
            if (teacherX < maxX) {
                agents.push(new Agent(teacherX, teacherY, 2)); // Type 2 (Informed Navigator)
            }
            
            // Set destination at the top-left exit
            destination = new Destination(roomLeft + exitWidth/2, roomTop - 20);
            
            updatePathfinding();
            render();
            updateUI();
        });
        
        // LLM Provider Selection
        document.getElementById('llmProvider').addEventListener('change', (e) => {
            const provider = e.target.value;
            const geminiConfig = document.getElementById('geminiConfig');
            const ollamaConfig = document.getElementById('ollamaConfig');
            
            if (provider === 'gemini') {
                geminiConfig.style.display = 'block';
                ollamaConfig.style.display = 'none';
            } else if (provider === 'ollama') {
                geminiConfig.style.display = 'none';
                ollamaConfig.style.display = 'block';
            }
        });
        
        // AI Scenario Generator
        document.getElementById('generateScenarioBtn').addEventListener('click', async () => {
            const provider = document.getElementById('llmProvider').value;
            const prompt = document.getElementById('scenarioPrompt').value.trim();
            const progressDiv = document.getElementById('generationProgress');
            
            if (!prompt) {
                progressDiv.textContent = 'Error: Please enter a scenario description';
                progressDiv.style.color = '#ff4444';
                return;
            }
            
            // Validate provider-specific requirements
            if (provider === 'gemini') {
                const apiKey = document.getElementById('geminiApiKey').value.trim();
                if (!apiKey) {
                    progressDiv.textContent = 'Error: Please enter your Gemini API key';
                    progressDiv.style.color = '#ff4444';
                    return;
                }
            } else if (provider === 'ollama') {
                const ollamaUrl = document.getElementById('ollamaUrl').value.trim();
                const ollamaModel = document.getElementById('ollamaModel').value.trim();
                if (!ollamaUrl || !ollamaModel) {
                    progressDiv.textContent = 'Error: Please enter Ollama URL and model name';
                    progressDiv.style.color = '#ff4444';
                    return;
                }
            }
            
            try {
                progressDiv.textContent = `Generating scenario with ${provider === 'gemini' ? 'Gemini' : 'Ollama'}...`;
                progressDiv.style.color = '#00ffff';
                
                let response;
                if (provider === 'gemini') {
                    const apiKey = document.getElementById('geminiApiKey').value.trim();
                    response = await generateScenarioWithGemini(apiKey, prompt);
                } else if (provider === 'ollama') {
                    const ollamaUrl = document.getElementById('ollamaUrl').value.trim();
                    const ollamaModel = document.getElementById('ollamaModel').value.trim();
                    response = await generateScenarioWithOllama(ollamaUrl, ollamaModel, prompt);
                }
                
                progressDiv.textContent = 'Parsing and creating scenario...';
                
                // Parse and apply the generated scenario
                await applyGeneratedScenario(response);
                
                progressDiv.textContent = 'Scenario generated successfully!';
                progressDiv.style.color = '#4CAF50';
                
                // Clear the progress message after 3 seconds
                setTimeout(() => {
                    progressDiv.textContent = '';
                }, 3000);
                
            } catch (error) {
                console.error('Error generating scenario:', error);
                
                // Provide specific error messages based on error type
                let errorMessage = error.message;
                if (error.message.includes('503')) {
                    errorMessage = 'Gemini API temporarily unavailable (503). Please try again in a few moments.';
                } else if (error.message.includes('429')) {
                    errorMessage = 'Rate limit exceeded. Please wait a moment and try again.';
                } else if (error.message.includes('400')) {
                    errorMessage = 'Invalid request. Please check your prompt and try again.';
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    errorMessage = 'API key invalid or unauthorized. Please check your API key.';
                }
                
                progressDiv.innerHTML = `${errorMessage}<br><small style="color: #888;">You can also try the pre-built scenarios below while the API recovers.</small>`;
                progressDiv.style.color = '#ff4444';
            }
        });
        
        async function generateScenarioWithGemini(apiKey, prompt) {
            // Enhance prompt with RAG if available
            if (typeof ragSystem !== 'undefined' && ragSystem.isInitialized) {
                prompt = ragSystem.enhancePrompt(prompt);
            }
            
            const systemPrompt = `You are a crowd simulation scenario generator. Generate a JSON response that describes a crowd evacuation scenario based on the user's prompt. 

The response should include:
1. walls: Array of wall objects with {x1, y1, x2, y2} coordinates (canvas is 800x600)
2. agents: Array of agent objects with {x, y, type} where type is 0-4
3. fires: Array of fire objects with {x, y} coordinates (USE STRATEGICALLY - see guidelines below)
4. destination: Object with {x, y} coordinates for the exit
5. description: Brief description of the scenario

Agent types:
- Type 0: Visual Explorer (cyan) - Can only see obstacles within vision range
- Type 1: Random Explorer (purple) - Explores randomly until destination is visible
- Type 2: Informed Navigator (orange) - Knows the full map, uses optimal pathfinding
- Type 3: Follower (red-orange) - Follows nearest Type 2 agent using simple movement
- Type 4: Smart Follower (purple) - Uses A* pathfinding to reach nearest Type 2 agent

FIRE USAGE GUIDELINES:
- Fires create danger zones that repel agents and can kill them if they get too close
- Use fires to simulate:
  * Building fires (place in rooms/corridors to block paths)
  * Kitchen fires (place in kitchen areas)
  * Electrical fires (place near equipment/server rooms)
  * Vehicle fires (place in parking areas)
  * Industrial accidents (place in factory/warehouse areas)
- Strategic placement: Block optimal escape routes to force agents to find alternatives
- Realistic scenarios: Don't overuse fires - 1-3 fires per scenario is usually sufficient
- Fire effects: Agents will avoid fires and may die if forced too close by crowds

CRITICAL: DOOR AND OPENING CREATION GUIDELINES:
When the user mentions ANY of these keywords, you MUST create openings in walls:
- "door", "doors", "doorway", "doorways"
- "exit", "exits", "escape", "escape point", "escape route"
- "opening", "openings", "passage", "passageway"
- "entrance", "gateway", "access point"

HOW TO CREATE OPENINGS:
1. BREAK WALLS INTO SEGMENTS: Instead of one long wall, create multiple shorter walls with gaps
2. STANDARD DOOR WIDTH: Leave 40-60 pixel gaps for doors
3. EMERGENCY EXIT WIDTH: Leave 60-80 pixel gaps for emergency exits
4. MULTIPLE EXITS: Always provide at least 2 escape routes when possible

EXAMPLES OF PROPER OPENING CREATION:

❌ WRONG - Solid wall with no openings:
{"x1": 100, "y1": 100, "x2": 700, "y2": 100}

✅ CORRECT - Wall with door opening:
[
  {"x1": 100, "y1": 100, "x2": 300, "y2": 100},
  {"x1": 350, "y1": 100, "x2": 700, "y2": 100}
]
(This creates a 50-pixel door opening between x=300 and x=350)

✅ CORRECT - Wall with multiple doors:
[
  {"x1": 100, "y1": 100, "x2": 250, "y2": 100},
  {"x1": 300, "y1": 100, "x2": 450, "y2": 100},
  {"x1": 500, "y1": 100, "x2": 700, "y2": 100}
]
(This creates two 50-pixel openings: x=250-300 and x=450-500)

ROOM WITH DOORS EXAMPLE:
{
  "walls": [
    {"x1": 100, "y1": 100, "x2": 250, "y2": 100},
    {"x1": 300, "y1": 100, "x2": 700, "y2": 100},
    {"x1": 700, "y1": 100, "x2": 700, "y2": 300},
    {"x1": 700, "y1": 300, "x2": 550, "y2": 300},
    {"x1": 500, "y1": 300, "x2": 100, "y2": 300},
    {"x1": 100, "y1": 300, "x2": 100, "y2": 100}
  ],
  "description": "Room with door at top (x=250-300) and emergency exit at bottom (x=500-550)"
}

SCENARIO EXAMPLES:

Office Building with Emergency Exits:
{
  "walls": [
    {"x1": 100, "y1": 100, "x2": 250, "y2": 100},
    {"x1": 300, "y1": 100, "x2": 700, "y2": 100},
    {"x1": 100, "y1": 100, "x2": 100, "y2": 180},
    {"x1": 100, "y1": 230, "x2": 100, "y2": 400},
    {"x1": 700, "y1": 100, "x2": 700, "y2": 400},
    {"x1": 100, "y1": 400, "x2": 350, "y2": 400},
    {"x1": 410, "y1": 400, "x2": 700, "y2": 400},
    {"x1": 300, "y1": 100, "x2": 300, "y2": 250},
    {"x1": 500, "y1": 250, "x2": 500, "y2": 400}
  ],
  "agents": [
    {"x": 150, "y": 150, "type": 2},
    {"x": 200, "y": 180, "type": 3},
    {"x": 250, "y": 160, "type": 3},
    {"x": 550, "y": 300, "type": 1},
    {"x": 600, "y": 320, "type": 0}
  ],
  "fires": [{"x": 400, "y": 200}],
  "destination": {"x": 275, "y": 50},
  "description": "Office with main door (top: x=250-300), side exit (left: y=180-230), and emergency exit (bottom: x=350-410)"
}

School Classroom Evacuation:
{
  "walls": [
    {"x1": 50, "y1": 50, "x2": 750, "y2": 50},
    {"x1": 50, "y1": 50, "x2": 50, "y2": 350},
    {"x1": 750, "y1": 50, "x2": 750, "y2": 350},
    {"x1": 50, "y1": 350, "x2": 200, "y2": 350},
    {"x1": 250, "y1": 350, "x2": 550, "y2": 350},
    {"x1": 600, "y1": 350, "x2": 750, "y2": 350},
    {"x1": 200, "y1": 200, "x2": 350, "y2": 200},
    {"x1": 400, "y1": 200, "x2": 700, "y2": 200}
  ],
  "agents": [
    {"x": 300, "y": 120, "type": 2},
    {"x": 250, "y": 140, "type": 3},
    {"x": 350, "y": 140, "type": 3},
    {"x": 600, "y": 120, "type": 2},
    {"x": 550, "y": 140, "type": 3},
    {"x": 650, "y": 140, "type": 3}
  ],
  "fires": [{"x": 150, "y": 280}],
  "destination": {"x": 225, "y": 380},
  "description": "School with main exit (bottom: x=250-550), emergency exit (bottom: x=550-600), and classroom doors (middle: x=350-400)"
}

Keep coordinates within canvas bounds (0-800 width, 0-600 height). Make realistic evacuation scenarios with appropriate agent type distribution and strategic fire placement.`;

            const fullPrompt = `${systemPrompt}\n\nUser request: ${prompt}\n\nGenerate the JSON scenario:`;
            
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: fullPrompt
                        }]
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Invalid response from Gemini API');
            }
            
            const generatedText = data.candidates[0].content.parts[0].text;
            
            // Extract JSON from the response (it might be wrapped in markdown code blocks)
            const jsonMatch = generatedText.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/) || 
                             generatedText.match(/(\{[\s\S]*\})/);
            
            if (!jsonMatch) {
                throw new Error('Could not extract JSON from Gemini response');
            }
            
            return JSON.parse(jsonMatch[1]);
        }
        
        async function generateScenarioWithOllama(ollamaUrl, model, prompt) {
            const systemPrompt = `You are a crowd simulation scenario generator. Generate a JSON response that describes a crowd evacuation scenario based on the user's prompt. 

The response should include:
1. walls: Array of wall objects with {x1, y1, x2, y2} coordinates (canvas is 800x600)
2. agents: Array of agent objects with {x, y, type} where type is 0-4
3. fires: Array of fire objects with {x, y} coordinates (USE STRATEGICALLY - see guidelines below)
4. destination: Object with {x, y} coordinates for the exit
5. description: Brief description of the scenario

Agent types:
- Type 0: Visual Explorer (cyan) - Can only see obstacles within vision range
- Type 1: Random Explorer (purple) - Explores randomly until destination is visible
- Type 2: Informed Navigator (orange) - Knows the full map, uses optimal pathfinding
- Type 3: Follower (red-orange) - Follows nearest Type 2 agent using simple movement
- Type 4: Smart Follower (purple) - Uses A* pathfinding to reach nearest Type 2 agent

CRITICAL: DOOR AND OPENING CREATION GUIDELINES:
When the user mentions ANY of these keywords, you MUST create openings in walls:
- "door", "doors", "doorway", "doorways"
- "exit", "exits", "escape", "escape point", "escape route"
- "opening", "openings", "passage", "passageway"
- "entrance", "gateway", "access point"

HOW TO CREATE OPENINGS:
1. BREAK WALLS INTO SEGMENTS: Instead of one long wall, create multiple shorter walls with gaps
2. STANDARD DOOR WIDTH: Leave 40-60 pixel gaps for doors
3. EMERGENCY EXIT WIDTH: Leave 60-80 pixel gaps for emergency exits
4. MULTIPLE EXITS: Always provide at least 2 escape routes when possible

FIRE USAGE: Use fires strategically to block paths and create realistic evacuation challenges. Place 1-3 fires per scenario.

Keep coordinates within canvas bounds (0-800 width, 0-600 height). Respond with ONLY the JSON, no additional text.`;

            const fullPrompt = `${systemPrompt}\n\nUser request: ${prompt}\n\nGenerate the JSON scenario:`;
            
            const response = await fetch(`${ollamaUrl}/api/generate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: model,
                    prompt: fullPrompt,
                    stream: false,
                    format: "json"
                })
            });
            
            if (!response.ok) {
                throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (!data.response) {
                throw new Error('Invalid response from Ollama API');
            }
            
            // Parse the JSON response
            try {
                return JSON.parse(data.response);
            } catch (parseError) {
                // If direct parsing fails, try to extract JSON from the response
                const jsonMatch = data.response.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/) || 
                                 data.response.match(/(\{[\s\S]*\})/);
                
                if (!jsonMatch) {
                    throw new Error('Could not extract JSON from Ollama response');
                }
                
                return JSON.parse(jsonMatch[1]);
            }
        }
        
        async function applyGeneratedScenario(scenarioData) {
            // Clear existing scenario
            agents = [];
            walls = [];
            doors = [];
            // Remove invisible walls for all fires before clearing
            for (const fire of fires) {
                fire.removeInvisibleWalls();
            }
            fires = [];
            destination = null;
            
            // Add walls
            if (scenarioData.walls) {
                for (const wall of scenarioData.walls) {
                    walls.push(new Wall(wall.x1, wall.y1, wall.x2, wall.y2));
                }
            }
            
            // Add agents
            if (scenarioData.agents) {
                for (const agent of scenarioData.agents) {
                    // Ensure agent type is valid (0-4)
                    const agentType = Math.max(0, Math.min(4, agent.type || 1));
                    // Ensure coordinates are within bounds
                    const x = Math.max(20, Math.min(780, agent.x || 100));
                    const y = Math.max(20, Math.min(580, agent.y || 100));
                    agents.push(new Agent(x, y, agentType));
                }
            }
            
            // Add fires
            if (scenarioData.fires) {
                for (const fire of scenarioData.fires) {
                    const x = Math.max(20, Math.min(780, fire.x || 100));
                    const y = Math.max(20, Math.min(580, fire.y || 100));
                    fires.push(new Fire(x, y));
                }
            }
            
            // Set destination
            if (scenarioData.destination) {
                const x = Math.max(20, Math.min(780, scenarioData.destination.x || 50));
                const y = Math.max(20, Math.min(580, scenarioData.destination.y || 50));
                destination = new Destination(x, y);
            }
            
            // Update the simulation
            updatePathfinding();
            render();
            updateUI();
        }
        
        // NEW: Diagonal Wall Test Scenario
        function createDiagonalWallTestScenario() {
            agents = [];
            walls = [];
            doors = [];
            destination = null;
            
            // Create diagonal wall that blocks direct path
            walls.push(new Wall(250, 150, 450, 350));
            
            // Add a few test agents on the left side
            for (let i = 0; i < 8; i++) {
                const x = 100 + Math.random() * 80;
                const y = 200 + Math.random() * 100;
                const rand = Math.random();
                let type;
                if (rand < 0.4) {
                    type = 1; // 40% Type 1
                } else if (rand < 0.7) {
                    type = 2; // 30% Type 2
                } else {
                    type = 3; // 30% Type 3 followers
                }
                agents.push(new Agent(x, y, type));
            }
            
            // Set destination on the right side (EXIT)
            destination = new Destination(550, 250);
            
            updatePathfinding();
            render();
            updateUI();
        }
        
        // Test the diagonal wall scenario immediately
        createDiagonalWallTestScenario();
        
        // Parameter controls
        document.getElementById('maxSpeed').addEventListener('input', (e) => {
            maxSpeed = parseFloat(e.target.value);
            document.getElementById('maxSpeedValue').textContent = maxSpeed.toFixed(1) + ' m/s';
        });
        
        document.getElementById('gridSize').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridSizeValue').textContent = gridSize + ' px';
            
            // Reinitialize pathfinding with new grid size
            if (gridManager) {
                initializePathfinding();
            }
        });
        
        document.getElementById('pathfindingFreq').addEventListener('input', (e) => {
            pathfindingFreq = parseFloat(e.target.value);
            document.getElementById('pathfindingFreqValue').textContent = pathfindingFreq.toFixed(1) + ' s';
        });
        
        document.getElementById('collisionRadius').addEventListener('input', (e) => {
            collisionRadius = parseInt(e.target.value);
            document.getElementById('collisionRadiusValue').textContent = collisionRadius + ' px';
        });
        
        document.getElementById('collisionStrength').addEventListener('input', (e) => {
            collisionStrength = parseFloat(e.target.value);
            document.getElementById('collisionStrengthValue').textContent = collisionStrength.toFixed(1);
        });
        
        // NEW: Wall repulsion strength control
        document.getElementById('wallRepulsionStrength').addEventListener('input', (e) => {
            wallRepulsionStrength = parseFloat(e.target.value);
            document.getElementById('wallRepulsionStrengthValue').textContent = wallRepulsionStrength.toFixed(1);
        });
        
        document.getElementById('visionConeDisplay').addEventListener('input', (e) => {
            visionConeDisplay = parseInt(e.target.value);
            document.getElementById('visionConeDisplayValue').textContent = visionConeDisplay + ' px';
        });
        
        document.getElementById('visionAngle').addEventListener('input', (e) => {
            visionAngle = parseInt(e.target.value);
            document.getElementById('visionAngleValue').textContent = visionAngle + '°';
        });
        
        // NEW: Agent collision radius control
        document.getElementById('agentCollisionRadius').addEventListener('input', (e) => {
            collisionRadius = parseInt(e.target.value);
            document.getElementById('agentCollisionRadiusValue').textContent = collisionRadius + ' px';
        });
        
        // NEW: Wall repulsion range control
        document.getElementById('wallRepulsionRange').addEventListener('input', (e) => {
            wallRepulsionRange = parseInt(e.target.value);
            document.getElementById('wallRepulsionRangeValue').textContent = wallRepulsionRange + ' px';
        });
        
        // Visualization controls
        document.getElementById('showGrid').addEventListener('change', (e) => {
            showGrid = e.target.checked;
        });
        
        document.getElementById('showPaths').addEventListener('change', (e) => {
            showPaths = e.target.checked;
        });
        
        document.getElementById('showVisionCones').addEventListener('change', (e) => {
            showVisionCones = e.target.checked;
        });
        
        document.getElementById('showCollisionCircles').addEventListener('change', (e) => {
            showCollisionCircles = e.target.checked;
        });
        
        document.getElementById('showCongestion').addEventListener('change', (e) => {
            showCongestion = e.target.checked;
        });
        
        // Initialize
        initializePathfinding();
        render();
        updateUI();
        
        // Line Detection Functions
        function detectLinesFromImage() {
            const fileInput = document.getElementById('imageUpload');
            const progressDiv = document.getElementById('detectionProgress');
            
            if (!fileInput.files[0]) {
                progressDiv.textContent = 'Please select an image first';
                return;
            }
            
            progressDiv.textContent = 'Processing image...';
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    processImageForLines(img, progressDiv);
                };
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }
        
        function processImageForLines(img, progressDiv) {
            progressDiv.textContent = 'Preprocessing image for 1920x1080 aspect ratio...';
            
            // Preprocess image to 1920x1080 aspect ratio
            const preprocessedData = preprocessImageAspectRatio(img);
            
            progressDiv.textContent = 'Converting to grayscale...';
            
            // Convert to grayscale
            const grayData = convertToGrayscale(preprocessedData.imageData);
            
            progressDiv.textContent = 'Detecting edges...';
            
            // Apply edge detection
            const edges = sobelEdgeDetection(grayData, preprocessedData.width, preprocessedData.height);
            
            progressDiv.textContent = 'Detecting lines...';
            
            // Detect lines
            const lines = detectLines(edges, preprocessedData.width, preprocessedData.height);
            
            progressDiv.textContent = 'Filtering and deduplicating lines...';
            
            // Filter lines (remove edges and text)
            const filteredLines = filterLines(lines, preprocessedData.width, preprocessedData.height);
            
            // Deduplicate overlapping lines
            const deduplicatedLines = deduplicateLines(filteredLines);
            
            progressDiv.textContent = 'Creating walls...';
            
            // Convert to simulation coordinates and create walls
            createWallsFromLines(deduplicatedLines, preprocessedData.width, preprocessedData.height);
            
            progressDiv.textContent = `Detected ${deduplicatedLines.length} lines and created walls`;
            
            // Update display
            render();
            updateUI();
        }
        
        function preprocessImageAspectRatio(img) {
            const targetAspectRatio = 1920 / 1080; // 16:9
            const imgAspectRatio = img.width / img.height;
            
            let canvasWidth, canvasHeight;
            let offsetX = 0, offsetY = 0;
            let drawWidth = img.width, drawHeight = img.height;
            
            if (imgAspectRatio > targetAspectRatio) {
                // Image is wider than target - add height padding
                canvasWidth = img.width;
                canvasHeight = Math.round(img.width / targetAspectRatio);
                offsetY = Math.round((canvasHeight - img.height) / 2);
            } else if (imgAspectRatio < targetAspectRatio) {
                // Image is taller than target - add width padding
                canvasHeight = img.height;
                canvasWidth = Math.round(img.height * targetAspectRatio);
                offsetX = Math.round((canvasWidth - img.width) / 2);
            } else {
                // Image already has correct aspect ratio
                canvasWidth = img.width;
                canvasHeight = img.height;
            }
            
            // Create canvas for preprocessing
            const preprocessCanvas = document.createElement('canvas');
            preprocessCanvas.width = canvasWidth;
            preprocessCanvas.height = canvasHeight;
            const preprocessCtx = preprocessCanvas.getContext('2d');
            
            // Fill with white background
            preprocessCtx.fillStyle = 'white';
            preprocessCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw original image centered
            preprocessCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
            
            // Get image data
            const imageData = preprocessCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            
            return {
                imageData: imageData,
                width: canvasWidth,
                height: canvasHeight,
                originalOffsetX: offsetX,
                originalOffsetY: offsetY
            };
        }
        
        function convertToGrayscale(imageData) {
            const data = imageData.data;
            const grayData = new Uint8Array(data.length / 4);
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                grayData[i / 4] = gray;
            }
            
            return grayData;
        }
        
        function sobelEdgeDetection(grayData, width, height) {
            const edges = new Uint8Array(width * height);
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            
            // First pass: Calculate gradients
            const gradients = new Float32Array(width * height);
            let maxGradient = 0;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = grayData[(y + ky) * width + (x + kx)];
                            const kernelIndex = (ky + 1) * 3 + (kx + 1);
                            gx += pixel * sobelX[kernelIndex];
                            gy += pixel * sobelY[kernelIndex];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    gradients[y * width + x] = magnitude;
                    maxGradient = Math.max(maxGradient, magnitude);
                }
            }
            
            // Second pass: Apply adaptive threshold and non-maximum suppression
            const threshold = Math.max(20, maxGradient * 0.1); // Adaptive threshold
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const current = gradients[y * width + x];
                    
                    if (current > threshold) {
                        // Check if this is a local maximum (non-maximum suppression)
                        const neighbors = [
                            gradients[(y-1) * width + (x-1)],
                            gradients[(y-1) * width + x],
                            gradients[(y-1) * width + (x+1)],
                            gradients[y * width + (x-1)],
                            gradients[y * width + (x+1)],
                            gradients[(y+1) * width + (x-1)],
                            gradients[(y+1) * width + x],
                            gradients[(y+1) * width + (x+1)]
                        ];
                        
                        const isLocalMax = neighbors.every(neighbor => current >= neighbor);
                        edges[y * width + x] = isLocalMax ? 255 : 0;
                    } else {
                        edges[y * width + x] = 0;
                    }
                }
            }
            
            // Third pass: Apply morphological operations to connect broken edges
            return morphologicalClose(edges, width, height);
        }
        
        function morphologicalClose(edges, width, height) {
            // Dilation followed by erosion to close small gaps
            const dilated = new Uint8Array(width * height);
            const kernel = [
                [0, 1, 0],
                [1, 1, 1],
                [0, 1, 0]
            ];
            
            // Dilation
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let maxVal = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            if (kernel[ky + 1][kx + 1] === 1) {
                                maxVal = Math.max(maxVal, edges[(y + ky) * width + (x + kx)]);
                            }
                        }
                    }
                    dilated[y * width + x] = maxVal;
                }
            }
            
            // Erosion
            const result = new Uint8Array(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let minVal = 255;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            if (kernel[ky + 1][kx + 1] === 1) {
                                minVal = Math.min(minVal, dilated[(y + ky) * width + (x + kx)]);
                            }
                        }
                    }
                    result[y * width + x] = minVal;
                }
            }
            
            return result;
        }
        
        function detectLines(edges, width, height) {
            const lines = [];
            const minLineLength = 30;
            const maxLineGap = 10;
            
            // Use a more robust line detection approach
            // First, find all edge pixels
            const edgePixels = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (edges[y * width + x] === 255) {
                        edgePixels.push({ x, y });
                    }
                }
            }
            
            // Group nearby edge pixels into line segments
            const visited = new Set();
            
            for (const pixel of edgePixels) {
                if (visited.has(`${pixel.x},${pixel.y}`)) continue;
                
                const lineSegment = growLineSegment(edges, width, height, pixel.x, pixel.y, visited, maxLineGap);
                
                if (lineSegment && lineSegment.length >= minLineLength) {
                    lines.push(lineSegment);
                }
            }
            
            return lines;
        }
        
        function growLineSegment(edges, width, height, startX, startY, visited, maxGap) {
            const segment = [{ x: startX, y: startY }];
            visited.add(`${startX},${startY}`);
            
            // Try to grow the segment in different directions
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 },  // up
                { dx: 1, dy: 1 },   // diagonal down-right
                { dx: -1, dy: -1 }, // diagonal up-left
                { dx: 1, dy: -1 },  // diagonal up-right
                { dx: -1, dy: 1 }   // diagonal down-left
            ];
            
            for (const dir of directions) {
                let x = startX + dir.dx;
                let y = startY + dir.dy;
                let gapCount = 0;
                const directionSegment = [];
                
                while (x >= 0 && x < width && y >= 0 && y < height && gapCount <= maxGap) {
                    if (edges[y * width + x] === 255 && !visited.has(`${x},${y}`)) {
                        directionSegment.push({ x, y });
                        visited.add(`${x},${y}`);
                        gapCount = 0;
                    } else if (edges[y * width + x] === 0) {
                        gapCount++;
                    }
                    
                    x += dir.dx;
                    y += dir.dy;
                }
                
                // Add the direction segment to the main segment
                if (directionSegment.length > 0) {
                    if (dir.dx < 0 || dir.dy < 0) {
                        // Prepend for negative directions
                        segment.unshift(...directionSegment.reverse());
                    } else {
                        // Append for positive directions
                        segment.push(...directionSegment);
                    }
                }
            }
            
            if (segment.length < 2) return null;
            
            // Calculate the line endpoints and length
            const start = segment[0];
            const end = segment[segment.length - 1];
            const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            
            return {
                start: start,
                end: end,
                length: length
            };
        }
        
        function filterLines(lines, imageWidth, imageHeight) {
            const edgeMargin = parseInt(document.getElementById('edgeMargin').value);
            
            return lines.filter(line => {
                // Filter out lines too close to image edges
                if (line.start.x < edgeMargin || line.start.x > imageWidth - edgeMargin ||
                    line.start.y < edgeMargin || line.start.y > imageHeight - edgeMargin ||
                    line.end.x < edgeMargin || line.end.x > imageWidth - edgeMargin ||
                    line.end.y < edgeMargin || line.end.y > imageHeight - edgeMargin) {
                    return false;
                }
                
                // Filter out very short lines (likely text)
                if (line.length < 30) {
                    return false;
                }
                
                return true;
            });
        }
        
        function deduplicateLines(lines) {
            const deduplicatedLines = [];
            const mergeThreshold = 15; // Distance threshold for merging lines
            const angleThreshold = 10; // Angle threshold in degrees
            
            for (const line of lines) {
                let merged = false;
                
                for (let i = 0; i < deduplicatedLines.length; i++) {
                    const existingLine = deduplicatedLines[i];
                    
                    // Check if lines are similar enough to merge
                    if (shouldMergeLines(line, existingLine, mergeThreshold, angleThreshold)) {
                        // Merge the lines by extending the existing line
                        deduplicatedLines[i] = mergeLines(line, existingLine);
                        merged = true;
                        break;
                    }
                }
                
                if (!merged) {
                    deduplicatedLines.push(line);
                }
            }
            
            return deduplicatedLines;
        }
        
        function shouldMergeLines(line1, line2, distanceThreshold, angleThreshold) {
            // Calculate angles of both lines
            const angle1 = Math.atan2(line1.end.y - line1.start.y, line1.end.x - line1.start.x) * 180 / Math.PI;
            const angle2 = Math.atan2(line2.end.y - line2.start.y, line2.end.x - line2.start.x) * 180 / Math.PI;
            
            // Normalize angles to [0, 180]
            const normalizedAngle1 = Math.abs(angle1) > 90 ? Math.abs(angle1) - 180 : Math.abs(angle1);
            const normalizedAngle2 = Math.abs(angle2) > 90 ? Math.abs(angle2) - 180 : Math.abs(angle2);
            
            const angleDiff = Math.abs(normalizedAngle1 - normalizedAngle2);
            
            // Check if angles are similar
            if (angleDiff > angleThreshold && angleDiff < (180 - angleThreshold)) {
                return false;
            }
            
            // Check if lines are close enough
            const minDistance = Math.min(
                distancePointToLine(line1.start, line2),
                distancePointToLine(line1.end, line2),
                distancePointToLine(line2.start, line1),
                distancePointToLine(line2.end, line1)
            );
            
            return minDistance < distanceThreshold;
        }
        
        function distancePointToLine(point, line) {
            const A = line.end.x - line.start.x;
            const B = line.end.y - line.start.y;
            const C = point.x - line.start.x;
            const D = point.y - line.start.y;
            
            const dot = A * C + B * D;
            const lenSq = A * A + B * B;
            
            if (lenSq === 0) return Math.sqrt(C * C + D * D);
            
            const param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = line.start.x;
                yy = line.start.y;
            } else if (param > 1) {
                xx = line.end.x;
                yy = line.end.y;
            } else {
                xx = line.start.x + param * A;
                yy = line.start.y + param * B;
            }
            
            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function mergeLines(line1, line2) {
            // Find the extreme points to create the merged line
            const allPoints = [line1.start, line1.end, line2.start, line2.end];
            
            // Calculate the line direction
            const dx1 = line1.end.x - line1.start.x;
            const dy1 = line1.end.y - line1.start.y;
            const dx2 = line2.end.x - line2.start.x;
            const dy2 = line2.end.y - line2.start.y;
            
            // Use the longer line's direction
            const useDirection1 = line1.length >= line2.length;
            const dx = useDirection1 ? dx1 : dx2;
            const dy = useDirection1 ? dy1 : dy2;
            
            // Project all points onto the line direction and find extremes
            let minProj = Infinity, maxProj = -Infinity;
            let minPoint = null, maxPoint = null;
            
            for (const point of allPoints) {
                const proj = point.x * dx + point.y * dy;
                if (proj < minProj) {
                    minProj = proj;
                    minPoint = point;
                }
                if (proj > maxProj) {
                    maxProj = proj;
                    maxPoint = point;
                }
            }
            
            const mergedLength = Math.sqrt(
                Math.pow(maxPoint.x - minPoint.x, 2) + 
                Math.pow(maxPoint.y - minPoint.y, 2)
            );
            
            return {
                start: minPoint,
                end: maxPoint,
                length: mergedLength
            };
        }
        
        function createWallsFromLines(lines, imageWidth, imageHeight) {
            // Get simulation canvas dimensions
            const simulationCanvas = document.getElementById('simulationCanvas');
            const canvasWidth = simulationCanvas.width;
            const canvasHeight = simulationCanvas.height;
            
            // Calculate scaling factors
            const scaleX = canvasWidth / imageWidth;
            const scaleY = canvasHeight / imageHeight;
            
            lines.forEach(line => {
                // Scale coordinates to simulation canvas
                const startX = Math.round(line.start.x * scaleX);
                const startY = Math.round(line.start.y * scaleY);
                const endX = Math.round(line.end.x * scaleX);
                const endY = Math.round(line.end.y * scaleY);
                
                // Create proper Wall object using the Wall class
                const wall = new Wall(startX, startY, endX, endY);
                walls.push(wall);
            });
            
            // Reinitialize pathfinding with new walls
            initializePathfinding();
        }
        
        // Event listeners for line detection
        document.getElementById('detectLinesBtn').addEventListener('click', detectLinesFromImage);
        
        document.getElementById('edgeMargin').addEventListener('input', (e) => {
            document.getElementById('edgeMarginValue').textContent = e.target.value;
        });

        // Initialize RAG system
        if (typeof ragSystem !== 'undefined') {
            ragSystem.initialize();
        }
    </script>
    <script src="rag_system_simple.js"></script>
    </body>
</html>

